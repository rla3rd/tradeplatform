<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>/home/orenmnero/autobuild/quickfix/src/C++/Utility.cpp Source File</title>
<link href="quickfix.css" rel="stylesheet" type="text/css">
<table cellspacing="0" cellpadding="0" border="0">
  <tr>
   <td><img src="images/outsideTopLeft.gif"></td>
   <td width="100%" class="outsideTop">&nbsp;</td>
   <td><img src="images/outsideTopRight.gif"></td>
  </tr>
  <tr>
   <td class="outsideLeft">&nbsp;</td>
   <td>
	<img src="images/QuickFIX.jpg" align="middle" border=0>
	&nbsp;&nbsp;
	<a href="index.html">Index</a>&nbsp;
	<a href="files.html">Source Files</a>&nbsp;
	<a href="annotated.html">Annotated Class List</a>&nbsp;
	<a href="classes.html">Alphabetical Class List</a>&nbsp;
	<a href="hierarchy.html">Class Hierarchy</a>&nbsp;
	<a href="inherits.html">Graphical Class Hierarchy</a>&nbsp;
   </td>
   <td class="outsideRight">&nbsp;</td>
  </tr>
  <tr>
   <td><img src="images/outsideBottomLeft.gif"></td>
   <td width=100% class="outsideBottom">&nbsp;</td>
   <td><img src="images/outsideBottomRight.gif"></td>
  </tr>
</table>
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.3.6-20040222 -->
<h1>/home/orenmnero/autobuild/quickfix/src/C++/Utility.cpp</h1><a href="_utility_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/****************************************************************************</span>
00002 <span class="comment">** Copyright (c) quickfixengine.org  All rights reserved.</span>
00003 <span class="comment">**</span>
00004 <span class="comment">** This file is part of the QuickFIX FIX Engine</span>
00005 <span class="comment">**</span>
00006 <span class="comment">** This file may be distributed under the terms of the quickfixengine.org</span>
00007 <span class="comment">** license as defined by quickfixengine.org and appearing in the file</span>
00008 <span class="comment">** LICENSE included in the packaging of this file.</span>
00009 <span class="comment">**</span>
00010 <span class="comment">** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE</span>
00011 <span class="comment">** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.</span>
00012 <span class="comment">**</span>
00013 <span class="comment">** See http://www.quickfixengine.org/LICENSE for licensing information.</span>
00014 <span class="comment">**</span>
00015 <span class="comment">** Contact ask@quickfixengine.org if any conditions of this licensing are</span>
00016 <span class="comment">** not clear to you.</span>
00017 <span class="comment">**</span>
00018 <span class="comment">****************************************************************************/</span>
00019 
00020 <span class="preprocessor">#ifdef _MSC_VER</span>
00021 <span class="preprocessor"></span><span class="preprocessor">#include "stdafx.h"</span>
00022 <span class="preprocessor">#else</span>
00023 <span class="preprocessor"></span><span class="preprocessor">#include "config.h"</span>
00024 <span class="preprocessor">#endif</span>
00025 <span class="preprocessor"></span><span class="preprocessor">#include "<a class="code" href="_call_stack_8h.html">CallStack.h</a>"</span>
00026 
00027 <span class="preprocessor">#include "<a class="code" href="_utility_8h.html">Utility.h</a>"</span>
00028 
00029 <span class="preprocessor">#ifdef USING_STREAMS</span>
00030 <span class="preprocessor"></span><span class="preprocessor">#include &lt;stropts.h&gt;</span>
00031 <span class="preprocessor">#include &lt;sys/conf.h&gt;</span>
00032 <span class="preprocessor">#endif</span>
00033 <span class="preprocessor"></span><span class="preprocessor">#include &lt;math.h&gt;</span>
00034 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00035 <span class="preprocessor">#include &lt;algorithm&gt;</span>
00036 
00037 <span class="keyword">namespace </span>FIX
00038 {
<a name="l00039"></a><a class="code" href="namespace_f_i_x.html#a2910">00039</a> <span class="keywordtype">void</span> <a class="code" href="namespace_f_i_x.html#a2910">string_replace</a>( <span class="keyword">const</span> std::string&amp; oldValue,
00040                              <span class="keyword">const</span> std::string&amp; newValue,
00041                              std::string&amp; value )
00042 { <a class="code" href="_call_stack_8h.html#a0">QF_STACK_PUSH</a>(<a class="code" href="namespace_f_i_x.html#a2910">string_replace</a>)
00043 
00044   <span class="keywordflow">for</span>( std::string::size_type pos = value.find(oldValue);
00045        pos != std::string::npos;
00046        pos = value.find(oldValue, pos) )
00047   {
00048     value.replace( pos, oldValue.size(), newValue );
00049     pos += newValue.size();
00050   }
00051 
00052   <a class="code" href="_call_stack_8h.html#a1">QF_STACK_POP</a>
00053 }
00054 
<a name="l00055"></a><a class="code" href="namespace_f_i_x.html#a2911">00055</a> std::string <a class="code" href="namespace_f_i_x.html#a2911">string_toUpper</a>( <span class="keyword">const</span> std::string&amp; value )
00056 { <a class="code" href="_call_stack_8h.html#a0">QF_STACK_PUSH</a>(<a class="code" href="namespace_f_i_x.html#a2911">string_toUpper</a>)
00057 
00058   std::string copy = value;
00059   std::transform( copy.begin(), copy.end(), copy.begin(), toupper );
00060   <span class="keywordflow">return</span> copy;
00061 
00062   <a class="code" href="_call_stack_8h.html#a1">QF_STACK_POP</a>
00063 }
00064 
<a name="l00065"></a><a class="code" href="namespace_f_i_x.html#a2912">00065</a> std::string <a class="code" href="namespace_f_i_x.html#a2912">string_toLower</a>( <span class="keyword">const</span> std::string&amp; value )
00066 { <a class="code" href="_call_stack_8h.html#a0">QF_STACK_PUSH</a>(<a class="code" href="namespace_f_i_x.html#a2912">string_toLower</a>)
00067 
00068   std::string copy = value;
00069   std::transform( copy.begin(), copy.end(), copy.begin(), tolower );
00070   <span class="keywordflow">return</span> copy;
00071 
00072   <a class="code" href="_call_stack_8h.html#a1">QF_STACK_POP</a>
00073 }
00074 
<a name="l00075"></a><a class="code" href="namespace_f_i_x.html#a2913">00075</a> <span class="keywordtype">void</span> <a class="code" href="namespace_f_i_x.html#a2913">socket_init</a>()
00076 { <a class="code" href="_call_stack_8h.html#a0">QF_STACK_PUSH</a>(<a class="code" href="namespace_f_i_x.html#a2913">socket_init</a>)
00077 
00078 #ifdef _MSC_VER
00079   WORD version = MAKEWORD( 2, 2 );
00080   WSADATA data;
00081   WSAStartup( version, &amp;data );
00082 <span class="preprocessor">#else</span>
00083 <span class="preprocessor"></span>  <span class="keyword">struct </span>sigaction sa;
00084   sa.sa_handler = SIG_IGN;
00085   sigemptyset( &amp;sa.sa_mask );
00086   sa.sa_flags = 0;
00087   sigaction( SIGPIPE, &amp;sa, 0 );
00088 <span class="preprocessor">#endif</span>
00089 <span class="preprocessor"></span>
00090   <a class="code" href="_call_stack_8h.html#a1">QF_STACK_POP</a>
00091 }
00092 
<a name="l00093"></a><a class="code" href="namespace_f_i_x.html#a2914">00093</a> <span class="keywordtype">void</span> <a class="code" href="namespace_f_i_x.html#a2914">socket_term</a>()
00094 { <a class="code" href="_call_stack_8h.html#a0">QF_STACK_PUSH</a>(<a class="code" href="namespace_f_i_x.html#a2914">socket_term</a>)
00095 
00096 #ifdef _MSC_VER
00097   WSACleanup();
00098 <span class="preprocessor">#endif</span>
00099 <span class="preprocessor"></span>
00100   <a class="code" href="_call_stack_8h.html#a1">QF_STACK_POP</a>
00101 }
00102 
<a name="l00103"></a><a class="code" href="namespace_f_i_x.html#a2915">00103</a> <span class="keywordtype">int</span> <a class="code" href="namespace_f_i_x.html#a2915">socket_createAcceptor</a>(<span class="keywordtype">int</span> port, <span class="keywordtype">bool</span> reuse)
00104 { <a class="code" href="_call_stack_8h.html#a0">QF_STACK_PUSH</a>(<a class="code" href="namespace_f_i_x.html#a2915">socket_createAcceptor</a>)
00105 
00106   <span class="keywordtype">int</span> socket = ::socket( PF_INET, SOCK_STREAM, 0 );
00107   <span class="keywordflow">if</span> ( socket &lt; 0 ) <span class="keywordflow">return</span> -1;
00108 
00109   sockaddr_in address;
00110   socklen_t socklen;
00111 
00112   address.sin_family = PF_INET;
00113   address.sin_port = htons( port );
00114   address.sin_addr.s_addr = INADDR_ANY;
00115   socklen = <span class="keyword">sizeof</span>( address );
00116   <span class="keywordflow">if</span>( reuse )
00117     <a class="code" href="namespace_f_i_x.html#a2923">socket_setsockopt</a>( socket, SO_REUSEADDR );
00118 
00119   <span class="keywordtype">int</span> result = bind( socket, reinterpret_cast &lt; sockaddr* &gt; ( &amp;address ),
00120                      socklen );
00121   <span class="keywordflow">if</span> ( result &lt; 0 ) <span class="keywordflow">return</span> -1;
00122   result = listen( socket, SOMAXCONN );
00123   <span class="keywordflow">if</span> ( result &lt; 0 ) <span class="keywordflow">return</span> -1;
00124   <span class="keywordflow">return</span> socket;
00125 
00126   <a class="code" href="_call_stack_8h.html#a1">QF_STACK_POP</a>
00127 }
00128 
<a name="l00129"></a><a class="code" href="namespace_f_i_x.html#a2916">00129</a> <span class="keywordtype">int</span> <a class="code" href="namespace_f_i_x.html#a2916">socket_createConnector</a>()
00130 { <a class="code" href="_call_stack_8h.html#a0">QF_STACK_PUSH</a>(<a class="code" href="namespace_f_i_x.html#a2916">socket_createConnector</a>)
00131   return ::socket( PF_INET, SOCK_STREAM, IPPROTO_TCP );
00132   <a class="code" href="_call_stack_8h.html#a1">QF_STACK_POP</a>
00133 }
00134 
<a name="l00135"></a><a class="code" href="namespace_f_i_x.html#a2917">00135</a> <span class="keywordtype">int</span> <a class="code" href="namespace_f_i_x.html#a2917">socket_connect</a>( <span class="keywordtype">int</span> socket, <span class="keyword">const</span> <span class="keywordtype">char</span>* address, <span class="keywordtype">int</span> port )
00136 { <a class="code" href="_call_stack_8h.html#a0">QF_STACK_PUSH</a>(<a class="code" href="namespace_f_i_x.html#a2917">socket_connect</a>)
00137 
00138   <span class="keyword">const</span> <span class="keywordtype">char</span>* hostname = <a class="code" href="namespace_f_i_x.html#a2933">socket_hostname</a>( address );
00139   <span class="keywordflow">if</span>( hostname == 0 ) <span class="keywordflow">return</span> -1;
00140 
00141   sockaddr_in addr;
00142   addr.sin_family = PF_INET;
00143   addr.sin_port = htons( port );
00144   addr.sin_addr.s_addr = inet_addr( hostname );
00145 
00146   <span class="keywordtype">int</span> result = connect( socket, reinterpret_cast &lt; sockaddr* &gt; ( &amp;addr ),
00147                         <span class="keyword">sizeof</span>( addr ) );
00148 
00149   <span class="keywordflow">return</span> result;
00150 
00151   <a class="code" href="_call_stack_8h.html#a1">QF_STACK_POP</a>
00152 }
00153 
<a name="l00154"></a><a class="code" href="namespace_f_i_x.html#a2918">00154</a> <span class="keywordtype">int</span> <a class="code" href="namespace_f_i_x.html#a2918">socket_accept</a>( <span class="keywordtype">int</span> s )
00155 { <a class="code" href="_call_stack_8h.html#a0">QF_STACK_PUSH</a>(<a class="code" href="namespace_f_i_x.html#a2918">socket_accept</a>)
00156 
00157   <span class="keywordflow">if</span> ( !<a class="code" href="namespace_f_i_x.html#a2929">socket_isValid</a>( s ) ) <span class="keywordflow">return</span> -1;
00158   <span class="keywordflow">return</span> accept( s, 0, 0 );
00159 
00160   <a class="code" href="_call_stack_8h.html#a1">QF_STACK_POP</a>
00161 }
00162 
<a name="l00163"></a><a class="code" href="namespace_f_i_x.html#a2919">00163</a> <span class="keywordtype">int</span> <a class="code" href="namespace_f_i_x.html#a2919">socket_send</a>( <span class="keywordtype">int</span> s, <span class="keyword">const</span> <span class="keywordtype">char</span>* msg, <span class="keywordtype">int</span> length )
00164 { <a class="code" href="_call_stack_8h.html#a0">QF_STACK_PUSH</a>(<a class="code" href="namespace_f_i_x.html#a2919">socket_send</a>)
00165   <span class="keywordflow">return</span> send( s, msg, length, 0 );
00166   <a class="code" href="_call_stack_8h.html#a1">QF_STACK_POP</a>
00167 }
00168 
<a name="l00169"></a><a class="code" href="namespace_f_i_x.html#a2920">00169</a> <span class="keywordtype">void</span> <a class="code" href="namespace_f_i_x.html#a2920">socket_close</a>( <span class="keywordtype">int</span> s )
00170 { <a class="code" href="_call_stack_8h.html#a0">QF_STACK_PUSH</a>(<a class="code" href="namespace_f_i_x.html#a2920">socket_close</a>)
00171 
00172   shutdown( s, 2 );
00173 <span class="preprocessor">#ifdef _MSC_VER</span>
00174 <span class="preprocessor"></span>  closesocket( s );
00175 <span class="preprocessor">#else</span>
00176 <span class="preprocessor"></span>  close( s );
00177 <span class="preprocessor">#endif</span>
00178 <span class="preprocessor"></span>
00179   <a class="code" href="_call_stack_8h.html#a1">QF_STACK_POP</a>
00180 }
00181 
<a name="l00182"></a><a class="code" href="namespace_f_i_x.html#a2921">00182</a> <span class="keywordtype">bool</span> <a class="code" href="namespace_f_i_x.html#a2921">socket_fionread</a>( <span class="keywordtype">int</span> s, <span class="keywordtype">int</span>&amp; bytes )
00183 { <a class="code" href="_call_stack_8h.html#a0">QF_STACK_PUSH</a>(<a class="code" href="namespace_f_i_x.html#a2921">socket_fionread</a>)
00184 
00185   bytes = 0;
00186 <span class="preprocessor">#if defined(_MSC_VER)</span>
00187 <span class="preprocessor"></span>  return ::ioctlsocket( s, FIONREAD, &amp;( ( <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>&amp; ) bytes ) ) == 0;
00188 <span class="preprocessor">#elif defined(USING_STREAMS)</span>
00189 <span class="preprocessor"></span>  return ::ioctl( s, I_NREAD, &amp;bytes ) &gt;= 0;
00190 <span class="preprocessor">#else</span>
00191 <span class="preprocessor"></span>  return ::ioctl( s, FIONREAD, &amp;bytes ) == 0;
00192 <span class="preprocessor">#endif</span>
00193 <span class="preprocessor"></span>
00194   <a class="code" href="_call_stack_8h.html#a1">QF_STACK_POP</a>
00195 }
00196 
<a name="l00197"></a><a class="code" href="namespace_f_i_x.html#a2922">00197</a> <span class="keywordtype">bool</span> <a class="code" href="namespace_f_i_x.html#a2922">socket_disconnected</a>( <span class="keywordtype">int</span> s )
00198 { <a class="code" href="_call_stack_8h.html#a0">QF_STACK_PUSH</a>(<a class="code" href="namespace_f_i_x.html#a2922">socket_disconnected</a>)
00199 
00200   <span class="keywordtype">char</span> byte;
00201   return ::recv (s, &amp;byte, <span class="keyword">sizeof</span> (byte), MSG_PEEK) &lt;= 0;
00202 
00203   <a class="code" href="_call_stack_8h.html#a1">QF_STACK_POP</a>
00204 }
00205 
<a name="l00206"></a><a class="code" href="namespace_f_i_x.html#a2923">00206</a> <span class="keywordtype">int</span> <a class="code" href="namespace_f_i_x.html#a2923">socket_setsockopt</a>( <span class="keywordtype">int</span> s, <span class="keywordtype">int</span> opt )
00207 { <a class="code" href="_call_stack_8h.html#a0">QF_STACK_PUSH</a>(<a class="code" href="namespace_f_i_x.html#a2923">socket_setsockopt</a>)
00208 
00209   <span class="keywordtype">int</span> level = SOL_SOCKET;
00210   <span class="keywordflow">if</span>( opt == TCP_NODELAY )
00211     level = IPPROTO_TCP;
00212 
00213 <span class="preprocessor">#ifdef _MSC_VER</span>
00214 <span class="preprocessor"></span>  BOOL optval = TRUE;
00215   return ::setsockopt( s, level, opt,
00216                        ( <span class="keywordtype">char</span>* ) &amp; optval, <span class="keyword">sizeof</span>( optval ) );
00217 <span class="preprocessor">#else</span>
00218 <span class="preprocessor"></span>  <span class="keywordtype">int</span> optval = 1;
00219   return ::setsockopt( s, level, opt,
00220                        &amp;optval, <span class="keyword">sizeof</span>( optval ) );
00221 <span class="preprocessor">#endif</span>
00222 <span class="preprocessor"></span>
00223   <a class="code" href="_call_stack_8h.html#a1">QF_STACK_POP</a>
00224 }
00225 
<a name="l00226"></a><a class="code" href="namespace_f_i_x.html#a2924">00226</a> <span class="keywordtype">int</span> <a class="code" href="namespace_f_i_x.html#a2924">socket_getsockopt</a>( <span class="keywordtype">int</span> s, <span class="keywordtype">int</span> opt, <span class="keywordtype">int</span>&amp; optval )
00227 { <a class="code" href="_call_stack_8h.html#a0">QF_STACK_PUSH</a>(<a class="code" href="namespace_f_i_x.html#a2924">socket_getsockopt</a>)
00228 
00229   <span class="keywordtype">int</span> level = SOL_SOCKET;
00230   <span class="keywordflow">if</span>( opt == TCP_NODELAY )
00231     level = IPPROTO_TCP;
00232 
00233 <span class="preprocessor">#ifdef _MSC_VER</span>
00234 <span class="preprocessor"></span>  <span class="keywordtype">int</span> length;
00235 <span class="preprocessor">#else</span>
00236 <span class="preprocessor"></span>  socklen_t length;
00237 <span class="preprocessor">#endif</span>
00238 <span class="preprocessor"></span>
00239   return ::getsockopt( s, level, opt, 
00240                        ( <span class="keywordtype">char</span>* ) &amp; optval, &amp; length );
00241 
00242   <a class="code" href="_call_stack_8h.html#a1">QF_STACK_POP</a>
00243 }
00244 
00245 <span class="preprocessor">#ifndef _MSC_VER</span>
<a name="l00246"></a><a class="code" href="namespace_f_i_x.html#a2925">00246</a> <span class="preprocessor"></span><span class="keywordtype">int</span> <a class="code" href="namespace_f_i_x.html#a2925">socket_fcntl</a>( <span class="keywordtype">int</span> s, <span class="keywordtype">int</span> opt, <span class="keywordtype">int</span> arg )
00247 { <a class="code" href="_call_stack_8h.html#a0">QF_STACK_PUSH</a>(<a class="code" href="namespace_f_i_x.html#a2925">socket_fcntl</a>)
00248   return ::fcntl( s, opt, arg );
00249   <a class="code" href="_call_stack_8h.html#a1">QF_STACK_POP</a>
00250 }
00251 
<a name="l00252"></a><a class="code" href="namespace_f_i_x.html#a2926">00252</a> <span class="keywordtype">int</span> <a class="code" href="namespace_f_i_x.html#a2926">socket_getfcntlflag</a>( <span class="keywordtype">int</span> s, <span class="keywordtype">int</span> arg )
00253 { <a class="code" href="_call_stack_8h.html#a0">QF_STACK_PUSH</a>(<a class="code" href="namespace_f_i_x.html#a2926">socket_getfcntlflag</a>)  
00254   <span class="keywordflow">return</span> <a class="code" href="namespace_f_i_x.html#a2925">socket_fcntl</a>( s, F_GETFL, arg );
00255   <a class="code" href="_call_stack_8h.html#a1">QF_STACK_POP</a>
00256 }
00257 
<a name="l00258"></a><a class="code" href="namespace_f_i_x.html#a2927">00258</a> <span class="keywordtype">int</span> <a class="code" href="namespace_f_i_x.html#a2927">socket_setfcntlflag</a>( <span class="keywordtype">int</span> s, <span class="keywordtype">int</span> arg )
00259 { <a class="code" href="_call_stack_8h.html#a0">QF_STACK_PUSH</a>(<a class="code" href="namespace_f_i_x.html#a2927">socket_setfcntlflag</a>)
00260 
00261   <span class="keywordtype">int</span> oldValue = <a class="code" href="namespace_f_i_x.html#a2926">socket_getfcntlflag</a>( s, arg );
00262   oldValue |= arg;
00263   <span class="keywordflow">return</span> <a class="code" href="namespace_f_i_x.html#a2925">socket_fcntl</a>( s, F_SETFL, arg );
00264 
00265   <a class="code" href="_call_stack_8h.html#a1">QF_STACK_POP</a>
00266 }
00267 <span class="preprocessor">#endif</span>
00268 <span class="preprocessor"></span>
<a name="l00269"></a><a class="code" href="namespace_f_i_x.html#a2928">00269</a> <span class="keywordtype">void</span> <a class="code" href="namespace_f_i_x.html#a2928">socket_setnonblock</a>( <span class="keywordtype">int</span> socket )
00270 { <a class="code" href="_call_stack_8h.html#a0">QF_STACK_PUSH</a>(<a class="code" href="namespace_f_i_x.html#a2928">socket_setnonblock</a>)
00271 
00272 #ifdef _MSC_VER
00273   u_long opt = 1;
00274   ::ioctlsocket( socket, FIONBIO, &amp;opt );
00275 <span class="preprocessor">#else</span>
00276 <span class="preprocessor"></span>  <a class="code" href="namespace_f_i_x.html#a2927">socket_setfcntlflag</a>( socket, O_NONBLOCK );
00277 <span class="preprocessor">#endif</span>
00278 <span class="preprocessor"></span>
00279   <a class="code" href="_call_stack_8h.html#a1">QF_STACK_POP</a>
00280 }
<a name="l00281"></a><a class="code" href="namespace_f_i_x.html#a2929">00281</a> <span class="keywordtype">bool</span> <a class="code" href="namespace_f_i_x.html#a2929">socket_isValid</a>( <span class="keywordtype">int</span> socket )
00282 { <a class="code" href="_call_stack_8h.html#a0">QF_STACK_PUSH</a>(<a class="code" href="namespace_f_i_x.html#a2929">socket_isValid</a>)
00283 
00284 #ifdef _MSC_VER
00285   <span class="keywordflow">return</span> socket != INVALID_SOCKET;
00286 <span class="preprocessor">#else</span>
00287 <span class="preprocessor"></span>  <span class="keywordflow">return</span> socket &gt;= 0;
00288 <span class="preprocessor">#endif</span>
00289 <span class="preprocessor"></span>
00290   <a class="code" href="_call_stack_8h.html#a1">QF_STACK_POP</a>
00291 }
00292 
00293 <span class="preprocessor">#ifndef _MSC_VER</span>
<a name="l00294"></a><a class="code" href="namespace_f_i_x.html#a2930">00294</a> <span class="preprocessor"></span><span class="keywordtype">bool</span> <a class="code" href="namespace_f_i_x.html#a2930">socket_isBad</a>( <span class="keywordtype">int</span> s )
00295 { <a class="code" href="_call_stack_8h.html#a0">QF_STACK_PUSH</a>(<a class="code" href="namespace_f_i_x.html#a2930">socket_isBad</a>)
00296 
00297   <span class="keyword">struct </span>stat buf;
00298   fstat( s, &amp;buf );
00299   <span class="keywordflow">return</span> errno == EBADF;
00300 
00301   <a class="code" href="_call_stack_8h.html#a1">QF_STACK_POP</a>
00302 }
00303 <span class="preprocessor">#endif</span>
00304 <span class="preprocessor"></span>
<a name="l00305"></a><a class="code" href="namespace_f_i_x.html#a2931">00305</a> <span class="keywordtype">void</span> <a class="code" href="namespace_f_i_x.html#a2931">socket_invalidate</a>( <span class="keywordtype">int</span>&amp; socket )
00306 { <a class="code" href="_call_stack_8h.html#a0">QF_STACK_PUSH</a>(<a class="code" href="namespace_f_i_x.html#a2931">socket_invalidate</a>)
00307 
00308 #ifdef _MSC_VER
00309   socket = INVALID_SOCKET;
00310 <span class="preprocessor">#else</span>
00311 <span class="preprocessor"></span>  socket = -1;
00312 <span class="preprocessor">#endif</span>
00313 <span class="preprocessor"></span>
00314   <a class="code" href="_call_stack_8h.html#a1">QF_STACK_POP</a>
00315 }
00316 
<a name="l00317"></a><a class="code" href="namespace_f_i_x.html#a2932">00317</a> <span class="keywordtype">short</span> <a class="code" href="namespace_f_i_x.html#a2932">socket_hostport</a>( <span class="keywordtype">int</span> socket )
00318 { <a class="code" href="_call_stack_8h.html#a0">QF_STACK_PUSH</a>(<a class="code" href="namespace_f_i_x.html#a2932">socket_hostport</a>)
00319 
00320   <span class="keyword">struct </span>sockaddr_in addr;
00321   socklen_t len = <span class="keyword">sizeof</span>(addr);
00322   <span class="keywordflow">if</span>( getsockname(socket, (<span class="keyword">struct</span> sockaddr*)&amp;addr, &amp;len) &lt; 0 )
00323     <span class="keywordflow">return</span> 0;
00324 
00325   <span class="keywordflow">return</span> ntohs( addr.sin_port );
00326   
00327   <a class="code" href="_call_stack_8h.html#a1">QF_STACK_POP</a>
00328 }
00329 
<a name="l00330"></a><a class="code" href="namespace_f_i_x.html#a2933">00330</a> <span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code" href="namespace_f_i_x.html#a2933">socket_hostname</a>( <span class="keywordtype">int</span> socket )
00331 { <a class="code" href="_call_stack_8h.html#a0">QF_STACK_PUSH</a>(<a class="code" href="namespace_f_i_x.html#a2933">socket_hostname</a>)
00332 
00333   <span class="keyword">struct </span>sockaddr_in addr;
00334   socklen_t len = <span class="keyword">sizeof</span>(addr);
00335   <span class="keywordflow">if</span>( getsockname(socket, (<span class="keyword">struct</span> sockaddr*)&amp;addr, &amp;len) &lt; 0 )
00336     <span class="keywordflow">return</span> 0;
00337 
00338   <span class="keywordflow">return</span> inet_ntoa( addr.sin_addr );
00339 
00340   <a class="code" href="_call_stack_8h.html#a1">QF_STACK_POP</a>
00341 }
00342 
<a name="l00343"></a><a class="code" href="namespace_f_i_x.html#a2934">00343</a> <span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code" href="namespace_f_i_x.html#a2933">socket_hostname</a>( <span class="keyword">const</span> <span class="keywordtype">char</span>* name )
00344 { <a class="code" href="_call_stack_8h.html#a0">QF_STACK_PUSH</a>(<a class="code" href="namespace_f_i_x.html#a2933">socket_hostname</a>)
00345 
00346   <span class="keyword">struct </span>hostent* host_ptr = 0;
00347   <span class="keyword">struct </span>in_addr** paddr;
00348   <span class="keyword">struct </span>in_addr saddr;
00349 
00350 <span class="preprocessor">#if( GETHOSTBYNAME_R_INPUTS_RESULT || GETHOSTBYNAME_R_RETURNS_RESULT )</span>
00351 <span class="preprocessor"></span>  hostent host;
00352   <span class="keywordtype">char</span> buf[1024];
00353   <span class="keywordtype">int</span> error;
00354 <span class="preprocessor">#endif</span>
00355 <span class="preprocessor"></span>
00356   saddr.s_addr = inet_addr( name );
00357   <span class="keywordflow">if</span> ( saddr.s_addr != ( <span class="keywordtype">unsigned</span> ) - 1 ) <span class="keywordflow">return</span> name;
00358 
00359 <span class="preprocessor">#if GETHOSTBYNAME_R_INPUTS_RESULT</span>
00360 <span class="preprocessor"></span>  gethostbyname_r( name, &amp;host, buf, <span class="keyword">sizeof</span>(buf), &amp;host_ptr, &amp;error );
00361 <span class="preprocessor">#elif GETHOSTBYNAME_R_RETURNS_RESULT</span>
00362 <span class="preprocessor"></span>  host_ptr = gethostbyname_r( name, &amp;host, buf, <span class="keyword">sizeof</span>(buf), &amp;error );
00363 <span class="preprocessor">#else</span>
00364 <span class="preprocessor"></span>  host_ptr = gethostbyname( name );
00365 <span class="preprocessor">#endif</span>
00366 <span class="preprocessor"></span>
00367   <span class="keywordflow">if</span> ( host_ptr == 0 ) <span class="keywordflow">return</span> 0;
00368 
00369   paddr = ( <span class="keyword">struct </span>in_addr ** ) host_ptr-&gt;h_addr_list;
00370   <span class="keywordflow">return</span> inet_ntoa( **paddr );
00371 
00372   <a class="code" href="_call_stack_8h.html#a1">QF_STACK_POP</a>
00373 }
00374 
<a name="l00375"></a><a class="code" href="namespace_f_i_x.html#a2935">00375</a> <span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code" href="namespace_f_i_x.html#a2935">socket_peername</a>( <span class="keywordtype">int</span> socket )
00376 { <a class="code" href="_call_stack_8h.html#a0">QF_STACK_PUSH</a>(<a class="code" href="namespace_f_i_x.html#a2935">socket_peername</a>)
00377 
00378   <span class="keyword">struct </span>sockaddr_in addr;
00379   socklen_t len = <span class="keyword">sizeof</span>(addr);
00380   <span class="keywordflow">if</span>( getpeername( socket, (<span class="keyword">struct</span> sockaddr*)&amp;addr, &amp;len ) &lt; 0 )
00381     <span class="keywordflow">return</span> 0;
00382   <span class="keywordflow">return</span> inet_ntoa( addr.sin_addr );
00383 
00384   <a class="code" href="_call_stack_8h.html#a1">QF_STACK_POP</a>
00385 }
00386 
<a name="l00387"></a><a class="code" href="namespace_f_i_x.html#a2936">00387</a> std::pair&lt;int, int&gt; <a class="code" href="namespace_f_i_x.html#a2936">socket_createpair</a>()
00388 { <a class="code" href="_call_stack_8h.html#a0">QF_STACK_PUSH</a>(<a class="code" href="namespace_f_i_x.html#a2936">socket_createpair</a>)
00389 
00390 #ifdef _MSC_VER
00391   <span class="keywordtype">int</span> acceptor = <a class="code" href="namespace_f_i_x.html#a2915">socket_createAcceptor</a>(0, <span class="keyword">true</span>);
00392   <span class="keyword">const</span> <span class="keywordtype">char</span>* host = <a class="code" href="namespace_f_i_x.html#a2933">socket_hostname</a>( acceptor );
00393   <span class="keywordtype">short</span> port = <a class="code" href="namespace_f_i_x.html#a2932">socket_hostport</a>( acceptor );
00394   <span class="keywordtype">int</span> client = <a class="code" href="namespace_f_i_x.html#a2916">socket_createConnector</a>();
00395   <a class="code" href="namespace_f_i_x.html#a2917">socket_connect</a>( client, <span class="stringliteral">"localhost"</span>, port );
00396   <span class="keywordtype">int</span> server = <a class="code" href="namespace_f_i_x.html#a2918">socket_accept</a>( acceptor );
00397   <span class="keywordflow">return</span> std::pair&lt;int, int&gt;( client, server );
00398 <span class="preprocessor">#else</span>
00399 <span class="preprocessor"></span>  <span class="keywordtype">int</span> pair[2];
00400   socketpair( AF_UNIX, SOCK_STREAM, 0, pair );
00401   <span class="keywordflow">return</span> std::pair&lt;int, int&gt;( pair[0], pair[1] );
00402 <span class="preprocessor">#endif</span>
00403 <span class="preprocessor"></span>
00404   <a class="code" href="_call_stack_8h.html#a1">QF_STACK_POP</a>
00405 }
00406 
<a name="l00407"></a><a class="code" href="namespace_f_i_x.html#a2937">00407</a> tm <a class="code" href="namespace_f_i_x.html#a2937">time_gmtime</a>( <span class="keyword">const</span> time_t* t )
00408 { <a class="code" href="_call_stack_8h.html#a0">QF_STACK_PUSH</a>(<a class="code" href="namespace_f_i_x.html#a2937">time_gmtime</a>)
00409 
00410 #ifdef _MSC_VER
00411 <span class="preprocessor">  #if( _MSC_VER &gt;= 1400 )</span>
00412 <span class="preprocessor"></span>    tm result;
00413     gmtime_s( &amp;result, t );
00414     <span class="keywordflow">return</span> result;
00415 <span class="preprocessor">  #else</span>
00416 <span class="preprocessor"></span>    <span class="keywordflow">return</span> *gmtime( t );
00417 <span class="preprocessor">  #endif</span>
00418 <span class="preprocessor"></span><span class="preprocessor">#else</span>
00419 <span class="preprocessor"></span>  tm result;
00420   <span class="keywordflow">return</span> *gmtime_r( t, &amp;result );
00421 <span class="preprocessor">#endif</span>
00422 <span class="preprocessor"></span>
00423   <a class="code" href="_call_stack_8h.html#a1">QF_STACK_POP</a>
00424 }
00425 
<a name="l00426"></a><a class="code" href="namespace_f_i_x.html#a2938">00426</a> tm <a class="code" href="namespace_f_i_x.html#a2938">time_localtime</a>( <span class="keyword">const</span> time_t* t)
00427 { <a class="code" href="_call_stack_8h.html#a0">QF_STACK_PUSH</a>(<a class="code" href="namespace_f_i_x.html#a2938">time_localtime</a>)
00428 
00429 #ifdef _MSC_VER
00430 <span class="preprocessor">  #if( _MSC_VER &gt;= 1400 )</span>
00431 <span class="preprocessor"></span>    tm result;
00432     localtime_s( &amp;result, t );
00433     <span class="keywordflow">return</span> result;
00434 <span class="preprocessor">  #else</span>
00435 <span class="preprocessor"></span>    <span class="keywordflow">return</span> *localtime( t );
00436 <span class="preprocessor">  #endif</span>
00437 <span class="preprocessor"></span><span class="preprocessor">#else</span>
00438 <span class="preprocessor"></span>  tm result;
00439   <span class="keywordflow">return</span> *localtime_r( t, &amp;result );
00440 <span class="preprocessor">#endif</span>
00441 <span class="preprocessor"></span>
00442   <a class="code" href="_call_stack_8h.html#a1">QF_STACK_POP</a>
00443 }
00444 
<a name="l00445"></a><a class="code" href="namespace_f_i_x.html#a2939">00445</a> <span class="keywordtype">bool</span> <a class="code" href="namespace_f_i_x.html#a2939">thread_spawn</a>( <a class="code" href="namespace_f_i_x.html#a227">THREAD_START_ROUTINE</a> func, <span class="keywordtype">void</span>* var, <span class="keywordtype">unsigned</span>&amp; thread )
00446 {
00447 <span class="preprocessor">#ifdef _MSC_VER</span>
00448 <span class="preprocessor"></span>  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> result = 0;
00449   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="keywordtype">id</span> = 0;
00450   result = _beginthreadex( NULL, 0, &amp;func, var, 0, &amp;<span class="keywordtype">id</span> );
00451   <span class="keywordflow">if</span> ( result == 0 ) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00452 <span class="preprocessor">#else</span>
00453 <span class="preprocessor"></span>  pthread_t result = 0;
00454   <span class="keywordflow">if</span>( pthread_create( &amp;result, 0, func, var ) != 0 ) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00455 <span class="preprocessor">#endif</span>
00456 <span class="preprocessor"></span>  thread = (<span class="keywordtype">unsigned</span>)result;
00457   <span class="keywordflow">return</span> <span class="keyword">true</span>;
00458 }
00459 
<a name="l00460"></a><a class="code" href="namespace_f_i_x.html#a2940">00460</a> <span class="keywordtype">bool</span> <a class="code" href="namespace_f_i_x.html#a2939">thread_spawn</a>( <a class="code" href="namespace_f_i_x.html#a227">THREAD_START_ROUTINE</a> func, <span class="keywordtype">void</span>* var )
00461 { <span class="keywordtype">unsigned</span> thread = 0;
00462   <span class="keywordflow">return</span> <a class="code" href="namespace_f_i_x.html#a2939">thread_spawn</a>( func, var, thread );
00463 }
00464 
<a name="l00465"></a><a class="code" href="namespace_f_i_x.html#a2941">00465</a> <span class="keywordtype">void</span> <a class="code" href="namespace_f_i_x.html#a2941">thread_join</a>( <span class="keywordtype">unsigned</span> thread )
00466 { <a class="code" href="_call_stack_8h.html#a0">QF_STACK_PUSH</a>(<a class="code" href="namespace_f_i_x.html#a2941">thread_join</a>)
00467 
00468 #ifdef _MSC_VER
00469   WaitForSingleObject( ( <span class="keywordtype">void</span>* ) thread, INFINITE );
00470   CloseHandle((HANDLE)thread);
00471 <span class="preprocessor">#else</span>
00472 <span class="preprocessor"></span>  pthread_join( ( pthread_t ) thread, 0 );
00473 <span class="preprocessor">#endif</span>
00474 <span class="preprocessor"></span>
00475   <a class="code" href="_call_stack_8h.html#a1">QF_STACK_POP</a>
00476 }
00477 
<a name="l00478"></a><a class="code" href="namespace_f_i_x.html#a2942">00478</a> <span class="keywordtype">void</span> <a class="code" href="namespace_f_i_x.html#a2942">thread_detach</a>( <span class="keywordtype">unsigned</span> thread )
00479 { <a class="code" href="_call_stack_8h.html#a0">QF_STACK_PUSH</a>(<a class="code" href="namespace_f_i_x.html#a2942">thread_detach</a>)
00480 
00481 #ifdef _MSC_VER
00482   CloseHandle((HANDLE)thread);
00483 <span class="preprocessor">#else</span>
00484 <span class="preprocessor"></span>  pthread_t t = (pthread_t)thread;
00485   pthread_detach( t );
00486 <span class="preprocessor">#endif</span>
00487 <span class="preprocessor"></span>
00488   <a class="code" href="_call_stack_8h.html#a1">QF_STACK_POP</a>
00489 }
00490 
<a name="l00491"></a><a class="code" href="namespace_f_i_x.html#a2943">00491</a> <span class="keywordtype">unsigned</span> <a class="code" href="namespace_f_i_x.html#a2943">thread_self</a>()
00492 {
00493 <span class="preprocessor">#ifdef _MSC_VER</span>
00494 <span class="preprocessor"></span>  <span class="keywordflow">return</span> ( <span class="keywordtype">unsigned</span> ) GetCurrentThread();
00495 <span class="preprocessor">#else</span>
00496 <span class="preprocessor"></span>  <span class="keywordflow">return</span> ( <span class="keywordtype">unsigned</span> ) pthread_self();
00497 <span class="preprocessor">#endif</span>
00498 <span class="preprocessor"></span>}
00499 
<a name="l00500"></a><a class="code" href="namespace_f_i_x.html#a2944">00500</a> <span class="keywordtype">void</span> <a class="code" href="namespace_f_i_x.html#a2944">process_sleep</a>( <span class="keywordtype">double</span> s )
00501 { <a class="code" href="_call_stack_8h.html#a0">QF_STACK_PUSH</a>(<a class="code" href="namespace_f_i_x.html#a2944">process_sleep</a>)
00502 
00503 #ifdef _MSC_VER
00504   Sleep( (<span class="keywordtype">long</span>)(s * 1000) );
00505 <span class="preprocessor">#else</span>
00506 <span class="preprocessor"></span>  timespec time, remainder;
00507   <span class="keywordtype">double</span> intpart;
00508   time.tv_nsec = (<span class="keywordtype">long</span>)(modf(s, &amp;intpart) * 1e9);
00509   time.tv_sec = (<span class="keywordtype">int</span>)intpart;
00510   <span class="keywordflow">while</span>( nanosleep(&amp;time, &amp;remainder) == -1 )
00511   time = remainder;
00512 <span class="preprocessor">#endif</span>
00513 <span class="preprocessor"></span>
00514   <a class="code" href="_call_stack_8h.html#a1">QF_STACK_POP</a>
00515 }
00516 
<a name="l00517"></a><a class="code" href="namespace_f_i_x.html#a2945">00517</a> std::string <a class="code" href="namespace_f_i_x.html#a2945">file_separator</a>()
00518 { <a class="code" href="_call_stack_8h.html#a0">QF_STACK_PUSH</a>(<a class="code" href="namespace_f_i_x.html#a2945">file_separator</a>)
00519 
00520 #ifdef _MSC_VER
00521   <span class="keywordflow">return</span> <span class="stringliteral">"\\"</span>;
00522 <span class="preprocessor">#else</span>
00523 <span class="preprocessor"></span>  <span class="keywordflow">return</span> <span class="stringliteral">"/"</span>;
00524 <span class="preprocessor">#endif</span>
00525 <span class="preprocessor"></span>
00526   <a class="code" href="_call_stack_8h.html#a1">QF_STACK_POP</a>
00527 }
00528 
<a name="l00529"></a><a class="code" href="namespace_f_i_x.html#a2946">00529</a> <span class="keywordtype">void</span> <a class="code" href="namespace_f_i_x.html#a2946">file_mkdir</a>( <span class="keyword">const</span> <span class="keywordtype">char</span>* path )
00530 { <a class="code" href="_call_stack_8h.html#a0">QF_STACK_PUSH</a>(<a class="code" href="namespace_f_i_x.html#a2946">file_mkdir</a>)
00531 
00532 #ifdef _MSC_VER
00533   _mkdir( path );
00534 <span class="preprocessor">#else</span>
00535 <span class="preprocessor"></span>  <span class="comment">// use umask to override rwx for all</span>
00536   mkdir( path, 0777 );
00537 <span class="preprocessor">#endif</span>
00538 <span class="preprocessor"></span>
00539   <a class="code" href="_call_stack_8h.html#a1">QF_STACK_POP</a>
00540 }
00541 
<a name="l00542"></a><a class="code" href="namespace_f_i_x.html#a2947">00542</a> FILE* <a class="code" href="namespace_f_i_x.html#a2947">file_fopen</a>( <span class="keyword">const</span> <span class="keywordtype">char</span>* path, <span class="keyword">const</span> <span class="keywordtype">char</span>* mode )
00543 { <a class="code" href="_call_stack_8h.html#a0">QF_STACK_PUSH</a>(<a class="code" href="namespace_f_i_x.html#a2947">file_fopen</a>)
00544 
00545 #<span class="keywordflow">if</span>( _MSC_VER &gt;= 1400 )
00546   FILE* result = 0;
00547   fopen_s( &amp;result, path, mode );
00548   <span class="keywordflow">return</span> result;
00549 <span class="preprocessor">#else</span>
00550 <span class="preprocessor"></span>  <span class="keywordflow">return</span> fopen( path, mode );
00551 <span class="preprocessor">#endif</span>
00552 <span class="preprocessor"></span>
00553   <a class="code" href="_call_stack_8h.html#a1">QF_STACK_POP</a>
00554 }
00555 
<a name="l00556"></a><a class="code" href="namespace_f_i_x.html#a2948">00556</a> <span class="keywordtype">void</span> <a class="code" href="namespace_f_i_x.html#a2948">file_unlink</a>( <span class="keyword">const</span> <span class="keywordtype">char</span>* path )
00557 { <a class="code" href="_call_stack_8h.html#a0">QF_STACK_PUSH</a>(<a class="code" href="namespace_f_i_x.html#a2948">file_unlink</a>)
00558 
00559 #ifdef _MSC_VER
00560   _unlink( path );
00561 <span class="preprocessor">#else</span>
00562 <span class="preprocessor"></span>  unlink( path );
00563 <span class="preprocessor">#endif</span>
00564 <span class="preprocessor"></span>
00565   <a class="code" href="_call_stack_8h.html#a1">QF_STACK_POP</a>
00566 }
00567 
<a name="l00568"></a><a class="code" href="namespace_f_i_x.html#a2949">00568</a> std::string <a class="code" href="namespace_f_i_x.html#a2949">file_appendpath</a>( <span class="keyword">const</span> std::string&amp; path, <span class="keyword">const</span> std::string&amp; file )
00569 { <a class="code" href="_call_stack_8h.html#a0">QF_STACK_PUSH</a>(<a class="code" href="namespace_f_i_x.html#a2949">file_appendpath</a>)
00570 
00571   <span class="keyword">const</span> <span class="keywordtype">char</span> last = path[path.size()-1];
00572   <span class="keywordflow">if</span>( last == <span class="charliteral">'/'</span> || last == <span class="charliteral">'\\'</span> )
00573     <span class="keywordflow">return</span> std::string(path) + file;
00574   <span class="keywordflow">else</span>
00575     <span class="keywordflow">return</span> std::string(path) + <a class="code" href="namespace_f_i_x.html#a2945">file_separator</a>() + file;
00576 
00577   <a class="code" href="_call_stack_8h.html#a1">QF_STACK_POP</a>
00578 }
00579 }
</pre></div><hr><address><small>
Generated on Thu Sep 14 08:52:37 2006 for QuickFIX by <a href="http://www.doxygen.org/index.html">
<img src="doxygen.gif" alt="doxygen" align="middle" border=0 width=110 height=53>
</a> 1.3.6-20040222 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,
 &copy;&nbsp;1997-2001</small></address>
</body>
</html>
