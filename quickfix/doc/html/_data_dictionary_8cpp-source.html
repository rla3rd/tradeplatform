<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>/home/orenmnero/autobuild/quickfix/src/C++/DataDictionary.cpp Source File</title>
<link href="quickfix.css" rel="stylesheet" type="text/css">
<table cellspacing="0" cellpadding="0" border="0">
  <tr>
   <td><img src="images/outsideTopLeft.gif"></td>
   <td width="100%" class="outsideTop">&nbsp;</td>
   <td><img src="images/outsideTopRight.gif"></td>
  </tr>
  <tr>
   <td class="outsideLeft">&nbsp;</td>
   <td>
	<img src="images/QuickFIX.jpg" align="middle" border=0>
	&nbsp;&nbsp;
	<a href="index.html">Index</a>&nbsp;
	<a href="files.html">Source Files</a>&nbsp;
	<a href="annotated.html">Annotated Class List</a>&nbsp;
	<a href="classes.html">Alphabetical Class List</a>&nbsp;
	<a href="hierarchy.html">Class Hierarchy</a>&nbsp;
	<a href="inherits.html">Graphical Class Hierarchy</a>&nbsp;
   </td>
   <td class="outsideRight">&nbsp;</td>
  </tr>
  <tr>
   <td><img src="images/outsideBottomLeft.gif"></td>
   <td width=100% class="outsideBottom">&nbsp;</td>
   <td><img src="images/outsideBottomRight.gif"></td>
  </tr>
</table>
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.3.6-20040222 -->
<h1>/home/orenmnero/autobuild/quickfix/src/C++/DataDictionary.cpp</h1><a href="_data_dictionary_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/****************************************************************************</span>
00002 <span class="comment">** Copyright (c) quickfixengine.org  All rights reserved.</span>
00003 <span class="comment">**</span>
00004 <span class="comment">** This file is part of the QuickFIX FIX Engine</span>
00005 <span class="comment">**</span>
00006 <span class="comment">** This file may be distributed under the terms of the quickfixengine.org</span>
00007 <span class="comment">** license as defined by quickfixengine.org and appearing in the file</span>
00008 <span class="comment">** LICENSE included in the packaging of this file.</span>
00009 <span class="comment">**</span>
00010 <span class="comment">** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE</span>
00011 <span class="comment">** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.</span>
00012 <span class="comment">**</span>
00013 <span class="comment">** See http://www.quickfixengine.org/LICENSE for licensing information.</span>
00014 <span class="comment">**</span>
00015 <span class="comment">** Contact ask@quickfixengine.org if any conditions of this licensing are</span>
00016 <span class="comment">** not clear to you.</span>
00017 <span class="comment">**</span>
00018 <span class="comment">****************************************************************************/</span>
00019 
00020 <span class="preprocessor">#ifdef _MSC_VER</span>
00021 <span class="preprocessor"></span><span class="preprocessor">#include "stdafx.h"</span>
00022 <span class="preprocessor">#else</span>
00023 <span class="preprocessor"></span><span class="preprocessor">#include "config.h"</span>
00024 <span class="preprocessor">#endif</span>
00025 <span class="preprocessor"></span><span class="preprocessor">#include "<a class="code" href="_call_stack_8h.html">CallStack.h</a>"</span>
00026 
00027 <span class="preprocessor">#include "<a class="code" href="_data_dictionary_8h.html">DataDictionary.h</a>"</span>
00028 <span class="preprocessor">#include "<a class="code" href="_message_8h.html">Message.h</a>"</span>
00029 <span class="preprocessor">#include &lt;fstream&gt;</span>
00030 <span class="preprocessor">#include &lt;memory&gt;</span>
00031 
00032 <span class="preprocessor">#ifdef HAVE_LIBXML</span>
00033 <span class="preprocessor"></span><span class="preprocessor">#include "<a class="code" href="_l_i_b_x_m_l___d_o_m_document_8h.html">LIBXML_DOMDocument.h</a>"</span>
00034 <span class="preprocessor">#elif _MSC_VER</span>
00035 <span class="preprocessor"></span><span class="preprocessor">#include "<a class="code" href="_m_s_x_m_l___d_o_m_document_8h.html">MSXML_DOMDocument.h</a>"</span>
00036 <span class="preprocessor">#else</span>
00037 <span class="preprocessor"></span><span class="preprocessor">#include "<a class="code" href="_l_i_b_x_m_l___d_o_m_document_8h.html">LIBXML_DOMDocument.h</a>"</span>
00038 <span class="preprocessor">#endif</span>
00039 <span class="preprocessor"></span>
00040 <span class="preprocessor">#ifdef _MSC_VER</span>
00041 <span class="preprocessor"></span><span class="preprocessor">#define RESET_AUTO_PTR(OLD, NEW) OLD = NEW;</span>
00042 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00043"></a><a class="code" href="_data_dictionary_8cpp.html#a0">00043</a> <span class="preprocessor"></span><span class="preprocessor">#define RESET_AUTO_PTR(OLD, NEW) OLD.reset( NEW.release() );</span>
00044 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00045 <span class="preprocessor"></span>
00046 <span class="keyword">namespace </span>FIX
00047 {
<a name="l00048"></a><a class="code" href="class_f_i_x_1_1_data_dictionary.html#a0">00048</a> DataDictionary::DataDictionary()
00049 : m_hasVersion( false ), m_checkFieldsOutOfOrder( true ),
00050   m_checkFieldsHaveValues( true ), m_checkUserDefinedFields( true ),
00051   m_orderedFieldsArray(0) {}
00052 
<a name="l00053"></a><a class="code" href="class_f_i_x_1_1_data_dictionary.html#a2">00053</a> DataDictionary::DataDictionary( std::istream&amp; stream )
00054 <span class="keywordflow">throw</span>( <a class="code" href="struct_f_i_x_1_1_config_error.html">ConfigError</a> )
00055 : m_hasVersion( <span class="keyword">false</span> ), m_checkFieldsOutOfOrder( <span class="keyword">true</span> ),
00056   m_checkFieldsHaveValues( <span class="keyword">true</span> ), m_checkUserDefinedFields( <span class="keyword">true</span> ),
00057   m_orderedFieldsArray(0)
00058 {
00059   readFromStream( stream );
00060 }
00061 
<a name="l00062"></a><a class="code" href="class_f_i_x_1_1_data_dictionary.html#a3">00062</a> DataDictionary::DataDictionary( <span class="keyword">const</span> std::string&amp; url )
00063 <span class="keywordflow">throw</span>( <a class="code" href="struct_f_i_x_1_1_config_error.html">ConfigError</a> )
00064 : m_hasVersion( <span class="keyword">false</span> ), m_checkFieldsOutOfOrder( <span class="keyword">true</span> ),
00065   m_checkFieldsHaveValues( <span class="keyword">true</span> ), m_checkUserDefinedFields( <span class="keyword">true</span> ),
00066   m_orderedFieldsArray(0)
00067 {
00068   readFromURL( url );
00069 }
00070 
<a name="l00071"></a><a class="code" href="class_f_i_x_1_1_data_dictionary.html#a1">00071</a> DataDictionary::DataDictionary( <span class="keyword">const</span> <a class="code" href="class_f_i_x_1_1_data_dictionary.html">DataDictionary</a>&amp; copy )
00072 {
00073   *<span class="keyword">this</span> = copy;
00074 }
00075 
<a name="l00076"></a><a class="code" href="class_f_i_x_1_1_data_dictionary.html#a4">00076</a> DataDictionary::~DataDictionary()
00077 {
00078   FieldToGroup::iterator i;
00079   <span class="keywordflow">for</span> ( i = <a class="code" href="class_f_i_x_1_1_data_dictionary.html#r18">m_groups</a>.begin(); i != <a class="code" href="class_f_i_x_1_1_data_dictionary.html#r18">m_groups</a>.end(); ++i )
00080     <span class="keyword">delete</span> i-&gt;second.second;
00081   <span class="keywordflow">if</span>( <a class="code" href="class_f_i_x_1_1_data_dictionary.html#r10">m_orderedFieldsArray</a> )
00082     <span class="keyword">delete</span> [] <a class="code" href="class_f_i_x_1_1_data_dictionary.html#r10">m_orderedFieldsArray</a>;
00083 }
00084 
<a name="l00085"></a><a class="code" href="class_f_i_x_1_1_data_dictionary.html#a42">00085</a> <a class="code" href="class_f_i_x_1_1_data_dictionary.html">DataDictionary</a>&amp; DataDictionary::operator=( <span class="keyword">const</span> <a class="code" href="class_f_i_x_1_1_data_dictionary.html">DataDictionary</a>&amp; rhs )
00086 { <a class="code" href="_call_stack_8h.html#a0">QF_STACK_PUSH</a>(DataDictionary::operator=)
00087 
00088   <a class="code" href="class_f_i_x_1_1_data_dictionary.html#r0">m_hasVersion</a> = rhs.<a class="code" href="class_f_i_x_1_1_data_dictionary.html#r0">m_hasVersion</a>;
00089   <a class="code" href="class_f_i_x_1_1_data_dictionary.html#r1">m_checkFieldsOutOfOrder</a> = rhs.<a class="code" href="class_f_i_x_1_1_data_dictionary.html#r1">m_checkFieldsOutOfOrder</a>;
00090   <a class="code" href="class_f_i_x_1_1_data_dictionary.html#r2">m_checkFieldsHaveValues</a> = rhs.<a class="code" href="class_f_i_x_1_1_data_dictionary.html#r2">m_checkFieldsHaveValues</a>;
00091   <a class="code" href="class_f_i_x_1_1_data_dictionary.html#r3">m_checkUserDefinedFields</a> = rhs.<a class="code" href="class_f_i_x_1_1_data_dictionary.html#r3">m_checkUserDefinedFields</a>;
00092   <a class="code" href="class_f_i_x_1_1_data_dictionary.html#r4">m_beginString</a> = rhs.<a class="code" href="class_f_i_x_1_1_data_dictionary.html#r4">m_beginString</a>;
00093   <a class="code" href="class_f_i_x_1_1_data_dictionary.html#r5">m_messageFields</a> = rhs.<a class="code" href="class_f_i_x_1_1_data_dictionary.html#r5">m_messageFields</a>;
00094   <a class="code" href="class_f_i_x_1_1_data_dictionary.html#r6">m_requiredFields</a> = rhs.<a class="code" href="class_f_i_x_1_1_data_dictionary.html#r6">m_requiredFields</a>;
00095   <a class="code" href="class_f_i_x_1_1_data_dictionary.html#r7">m_messages</a> = rhs.<a class="code" href="class_f_i_x_1_1_data_dictionary.html#r7">m_messages</a>;
00096   <a class="code" href="class_f_i_x_1_1_data_dictionary.html#r8">m_fields</a> = rhs.<a class="code" href="class_f_i_x_1_1_data_dictionary.html#r8">m_fields</a>;
00097   <a class="code" href="class_f_i_x_1_1_data_dictionary.html#r9">m_orderedFields</a> = rhs.<a class="code" href="class_f_i_x_1_1_data_dictionary.html#r9">m_orderedFields</a>;
00098   <a class="code" href="class_f_i_x_1_1_data_dictionary.html#r10">m_orderedFieldsArray</a> = 0;
00099   <a class="code" href="class_f_i_x_1_1_data_dictionary.html#r11">m_headerFields</a> = rhs.<a class="code" href="class_f_i_x_1_1_data_dictionary.html#r11">m_headerFields</a>;
00100   <a class="code" href="class_f_i_x_1_1_data_dictionary.html#r12">m_trailerFields</a> = rhs.<a class="code" href="class_f_i_x_1_1_data_dictionary.html#r12">m_trailerFields</a>;
00101   <a class="code" href="class_f_i_x_1_1_data_dictionary.html#r13">m_fieldTypes</a> = rhs.<a class="code" href="class_f_i_x_1_1_data_dictionary.html#r13">m_fieldTypes</a>;
00102   <a class="code" href="class_f_i_x_1_1_data_dictionary.html#r14">m_fieldValues</a> = rhs.<a class="code" href="class_f_i_x_1_1_data_dictionary.html#r14">m_fieldValues</a>;
00103   <a class="code" href="class_f_i_x_1_1_data_dictionary.html#r15">m_fieldNames</a> = rhs.<a class="code" href="class_f_i_x_1_1_data_dictionary.html#r15">m_fieldNames</a>;
00104   <a class="code" href="class_f_i_x_1_1_data_dictionary.html#r16">m_names</a> = rhs.<a class="code" href="class_f_i_x_1_1_data_dictionary.html#r16">m_names</a>;
00105   <a class="code" href="class_f_i_x_1_1_data_dictionary.html#r17">m_valueNames</a> = rhs.<a class="code" href="class_f_i_x_1_1_data_dictionary.html#r17">m_valueNames</a>;
00106 
00107   FieldToGroup::const_iterator i = rhs.<a class="code" href="class_f_i_x_1_1_data_dictionary.html#r18">m_groups</a>.begin();
00108   <span class="keywordflow">for</span> ( ; i != rhs.<a class="code" href="class_f_i_x_1_1_data_dictionary.html#r18">m_groups</a>.end(); ++i )
00109   {
00110     <a class="code" href="class_f_i_x_1_1_data_dictionary.html#a33">addGroup</a>( i-&gt;first.first, i-&gt;first.second,
00111               i-&gt;second.first, *i-&gt;second.second );
00112   }
00113   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00114 
00115   <a class="code" href="_call_stack_8h.html#a1">QF_STACK_POP</a>
00116 }
00117 
<a name="l00118"></a><a class="code" href="class_f_i_x_1_1_data_dictionary.html#a41">00118</a> <span class="keywordtype">void</span> DataDictionary::validate( <span class="keyword">const</span> <a class="code" href="class_f_i_x_1_1_message.html">Message</a>&amp; message )
00119 <span class="keywordflow">throw</span>( std::exception )
00120 { <a class="code" href="_call_stack_8h.html#a0">QF_STACK_PUSH</a>(DataDictionary::validate)
00121 
00122   <span class="keyword">const</span> <a class="code" href="class_f_i_x_1_1_field_map.html">Header</a>&amp; header = message.getHeader();
00123   <span class="keyword">const</span> BeginString&amp; beginString = <a class="code" href="_field_map_8h.html#a2">FIELD_GET_REF</a>( header, BeginString );
00124   <span class="keyword">const</span> MsgType&amp; msgType = <a class="code" href="_field_map_8h.html#a2">FIELD_GET_REF</a>( header, MsgType );
00125 
00126   std::string ddBeginString = getVersion();
00127   <span class="keywordflow">if</span> ( m_hasVersion &amp;&amp; m_beginString != beginString )
00128     <span class="keywordflow">throw</span> <a class="code" href="struct_f_i_x_1_1_unsupported_version.html">UnsupportedVersion</a>();
00129 
00130   <span class="keywordtype">int</span> field = 0;
00131   <span class="keywordflow">if</span> ( m_checkFieldsOutOfOrder &amp;&amp; !message.hasValidStructure(field) )
00132     <span class="keywordflow">throw</span> <a class="code" href="struct_f_i_x_1_1_tag_out_of_order.html">TagOutOfOrder</a>(field);
00133 
00134   <span class="keywordflow">if</span> ( m_hasVersion )
00135   {
00136     checkMsgType( msgType );
00137     checkHasRequired( message.getHeader(), message, message.getTrailer(), msgType );
00138   }
00139 
00140   iterate( message.getHeader(), msgType );
00141   iterate( message.getTrailer(), msgType );
00142   iterate( message, msgType );
00143 
00144   <a class="code" href="_call_stack_8h.html#a1">QF_STACK_POP</a>
00145 }
00146 
<a name="l00147"></a><a class="code" href="class_f_i_x_1_1_data_dictionary.html#d0">00147</a> <span class="keywordtype">void</span> DataDictionary::iterate( <span class="keyword">const</span> <a class="code" href="class_f_i_x_1_1_field_map.html">FieldMap</a>&amp; map, <span class="keyword">const</span> MsgType&amp; msgType )
00148 { <a class="code" href="_call_stack_8h.html#a0">QF_STACK_PUSH</a>(DataDictionary::iterate)
00149 
00150   <span class="keywordtype">int</span> lastField = 0;
00151 
00152   FieldMap::iterator i;
00153   <span class="keywordflow">for</span> ( i = map.<a class="code" href="class_f_i_x_1_1_field_map.html#a28">begin</a>(); i != map.<a class="code" href="class_f_i_x_1_1_field_map.html#a29">end</a>(); ++i )
00154   {
00155     <span class="keyword">const</span> <a class="code" href="class_f_i_x_1_1_field_base.html">FieldBase</a>&amp; field = i-&gt;second;
00156     <span class="keywordflow">if</span>( i != map.<a class="code" href="class_f_i_x_1_1_field_map.html#a28">begin</a>() &amp;&amp; (field.<a class="code" href="class_f_i_x_1_1_field_base.html#a3">getField</a>() == lastField) )
00157       <span class="keywordflow">throw</span> <a class="code" href="struct_f_i_x_1_1_repeated_tag.html">RepeatedTag</a>( lastField );
00158     <a class="code" href="class_f_i_x_1_1_data_dictionary.html#d6">checkHasValue</a>( field );
00159 
00160     <span class="keywordflow">if</span> ( <a class="code" href="class_f_i_x_1_1_data_dictionary.html#r0">m_hasVersion</a> )
00161     {
00162       <a class="code" href="class_f_i_x_1_1_data_dictionary.html#d4">checkValidFormat</a>( field );
00163       <a class="code" href="class_f_i_x_1_1_data_dictionary.html#d5">checkValue</a>( field );
00164     }
00165 
00166     <span class="keywordflow">if</span> ( <a class="code" href="class_f_i_x_1_1_data_dictionary.html#r4">m_beginString</a>.getValue().length() &amp;&amp; <a class="code" href="class_f_i_x_1_1_data_dictionary.html#d2">shouldCheckTag</a>(field) )
00167     {
00168       <a class="code" href="class_f_i_x_1_1_data_dictionary.html#d3">checkValidTagNumber</a>( field );
00169       <span class="keywordflow">if</span> ( !Message::isHeaderField( field, <span class="keyword">this</span> )
00170            &amp;&amp; !Message::isTrailerField( field, <span class="keyword">this</span> ) )
00171       {
00172         <a class="code" href="class_f_i_x_1_1_data_dictionary.html#d7">checkIsInMessage</a>( field, msgType );
00173         <a class="code" href="class_f_i_x_1_1_data_dictionary.html#d8">checkGroupCount</a>( field, map, msgType );
00174       }
00175     }
00176     lastField = field.<a class="code" href="class_f_i_x_1_1_field_base.html#a3">getField</a>();
00177   }
00178 
00179   <a class="code" href="_call_stack_8h.html#a1">QF_STACK_POP</a>
00180 }
00181 
<a name="l00182"></a><a class="code" href="class_f_i_x_1_1_data_dictionary.html#a5">00182</a> <span class="keywordtype">void</span> DataDictionary::readFromURL( <span class="keyword">const</span> std::string&amp; url )
00183 <span class="keywordflow">throw</span>( <a class="code" href="struct_f_i_x_1_1_config_error.html">ConfigError</a> )
00184 { <a class="code" href="_call_stack_8h.html#a0">QF_STACK_PUSH</a>(DataDictionary::readFromURL)
00185 
00186 #ifdef HAVE_LIBXML
00187   <a class="code" href="namespace_f_i_x.html#a80">DOMDocumentPtr</a> pDoc = <a class="code" href="namespace_f_i_x.html#a80">DOMDocumentPtr</a>(<span class="keyword">new</span> <a class="code" href="class_f_i_x_1_1_l_i_b_x_m_l___d_o_m_document.html">LIBXML_DOMDocument</a>());
00188 <span class="preprocessor">#elif _MSC_VER</span>
00189 <span class="preprocessor"></span>  <a class="code" href="namespace_f_i_x.html#a80">DOMDocumentPtr</a> pDoc = <a class="code" href="namespace_f_i_x.html#a80">DOMDocumentPtr</a>(<span class="keyword">new</span> <a class="code" href="class_f_i_x_1_1_m_s_x_m_l___d_o_m_document.html">MSXML_DOMDocument</a>());
00190 <span class="preprocessor">#else</span>
00191 <span class="preprocessor"></span>  <a class="code" href="namespace_f_i_x.html#a80">DOMDocumentPtr</a> pDoc = <a class="code" href="namespace_f_i_x.html#a80">DOMDocumentPtr</a>(<span class="keyword">new</span> <a class="code" href="class_f_i_x_1_1_l_i_b_x_m_l___d_o_m_document.html">LIBXML_DOMDocument</a>());
00192 <span class="preprocessor">#endif</span>
00193 <span class="preprocessor"></span>
00194   <span class="keywordflow">if</span>(!pDoc-&gt;load(url))
00195     <span class="keywordflow">throw</span> <a class="code" href="struct_f_i_x_1_1_config_error.html">ConfigError</a>(url + <span class="stringliteral">": Could not parse data dictionary file"</span>);
00196 
00197   <span class="keywordflow">try</span>
00198   {
00199     readFromDocument( pDoc );
00200   }
00201   <span class="keywordflow">catch</span>( <a class="code" href="struct_f_i_x_1_1_config_error.html">ConfigError</a>&amp; e )
00202   {
00203     <span class="keywordflow">throw</span> <a class="code" href="struct_f_i_x_1_1_config_error.html">ConfigError</a>( url + <span class="stringliteral">": "</span> + e.what() );
00204   }
00205 
00206   <a class="code" href="_call_stack_8h.html#a1">QF_STACK_POP</a>
00207 }
00208 
<a name="l00209"></a><a class="code" href="class_f_i_x_1_1_data_dictionary.html#a7">00209</a> <span class="keywordtype">void</span> DataDictionary::readFromStream( std::istream&amp; stream )
00210 <span class="keywordflow">throw</span>( <a class="code" href="struct_f_i_x_1_1_config_error.html">ConfigError</a> )
00211 { <a class="code" href="_call_stack_8h.html#a0">QF_STACK_PUSH</a>(DataDictionary::readFromStream)
00212 
00213 #ifdef HAVE_LIBXML
00214   <a class="code" href="namespace_f_i_x.html#a80">DOMDocumentPtr</a> pDoc = <a class="code" href="namespace_f_i_x.html#a80">DOMDocumentPtr</a>(<span class="keyword">new</span> <a class="code" href="class_f_i_x_1_1_l_i_b_x_m_l___d_o_m_document.html">LIBXML_DOMDocument</a>());
00215 <span class="preprocessor">#elif _MSC_VER</span>
00216 <span class="preprocessor"></span>  <a class="code" href="namespace_f_i_x.html#a80">DOMDocumentPtr</a> pDoc = <a class="code" href="namespace_f_i_x.html#a80">DOMDocumentPtr</a>(<span class="keyword">new</span> <a class="code" href="class_f_i_x_1_1_m_s_x_m_l___d_o_m_document.html">MSXML_DOMDocument</a>());
00217 <span class="preprocessor">#else</span>
00218 <span class="preprocessor"></span>  <a class="code" href="namespace_f_i_x.html#a80">DOMDocumentPtr</a> pDoc = <a class="code" href="namespace_f_i_x.html#a80">DOMDocumentPtr</a>(<span class="keyword">new</span> <a class="code" href="class_f_i_x_1_1_l_i_b_x_m_l___d_o_m_document.html">LIBXML_DOMDocument</a>());
00219 <span class="preprocessor">#endif</span>
00220 <span class="preprocessor"></span>
00221   <span class="keywordflow">if</span>(!pDoc-&gt;load(stream))
00222     <span class="keywordflow">throw</span> <a class="code" href="struct_f_i_x_1_1_config_error.html">ConfigError</a>(<span class="stringliteral">"Could not parse data dictionary stream"</span>);
00223 
00224   readFromDocument( pDoc );
00225 
00226   <a class="code" href="_call_stack_8h.html#a1">QF_STACK_POP</a>
00227 }
00228 
<a name="l00229"></a><a class="code" href="class_f_i_x_1_1_data_dictionary.html#a6">00229</a> <span class="keywordtype">void</span> DataDictionary::readFromDocument( <a class="code" href="namespace_f_i_x.html#a80">DOMDocumentPtr</a> pDoc )
00230 <span class="keywordflow">throw</span>( <a class="code" href="struct_f_i_x_1_1_config_error.html">ConfigError</a> )
00231 { <a class="code" href="_call_stack_8h.html#a0">QF_STACK_PUSH</a>(DataDictionary::readFromDocument)
00232 
00233   <span class="comment">// VERSION</span>
00234   <a class="code" href="namespace_f_i_x.html#a79">DOMNodePtr</a> pFixNode = pDoc-&gt;getNode(<span class="stringliteral">"/fix"</span>);
00235   <span class="keywordflow">if</span>(!pFixNode.get())
00236     <span class="keywordflow">throw</span> <a class="code" href="struct_f_i_x_1_1_config_error.html">ConfigError</a>(<span class="stringliteral">"Could not parse data dictionary file"</span>
00237                       <span class="stringliteral">", or no &lt;fix&gt; node found at root"</span>);
00238   <a class="code" href="namespace_f_i_x.html#a78">DOMAttributesPtr</a> attrs = pFixNode-&gt;getAttributes();
00239   std::string major;
00240   <span class="keywordflow">if</span>(!attrs-&gt;get(<span class="stringliteral">"major"</span>, major))
00241     <span class="keywordflow">throw</span> <a class="code" href="struct_f_i_x_1_1_config_error.html">ConfigError</a>(<span class="stringliteral">"major attribute not found on &lt;fix&gt;"</span>);
00242   std::string minor;
00243   <span class="keywordflow">if</span>(!attrs-&gt;get(<span class="stringliteral">"minor"</span>, minor))
00244     <span class="keywordflow">throw</span> <a class="code" href="struct_f_i_x_1_1_config_error.html">ConfigError</a>(<span class="stringliteral">"minor attribute not found on &lt;fix&gt;"</span>);
00245   setVersion(<span class="stringliteral">"FIX."</span> + major + <span class="stringliteral">"."</span> + minor);
00246 
00247   <span class="comment">// FIELDS</span>
00248   <a class="code" href="namespace_f_i_x.html#a79">DOMNodePtr</a> pFieldsNode = pDoc-&gt;getNode(<span class="stringliteral">"/fix/fields"</span>);
00249   <span class="keywordflow">if</span>(!pFieldsNode.get())
00250     <span class="keywordflow">throw</span> <a class="code" href="struct_f_i_x_1_1_config_error.html">ConfigError</a>(<span class="stringliteral">"&lt;fields&gt; section not found in data dictionary"</span>);
00251 
00252   <a class="code" href="namespace_f_i_x.html#a79">DOMNodePtr</a> pFieldNode = pFieldsNode-&gt;getFirstChildNode();
00253   <span class="keywordflow">if</span>(!pFieldNode.get()) <span class="keywordflow">throw</span> <a class="code" href="struct_f_i_x_1_1_config_error.html">ConfigError</a>(<span class="stringliteral">"No fields defined"</span>);
00254 
00255   <span class="keywordflow">while</span>(pFieldNode.get())
00256   {
00257     <span class="keywordflow">if</span>(pFieldNode-&gt;getName() == <span class="stringliteral">"field"</span>)
00258     {
00259       <a class="code" href="namespace_f_i_x.html#a78">DOMAttributesPtr</a> attrs = pFieldNode-&gt;getAttributes();
00260       std::string name;
00261       <span class="keywordflow">if</span>(!attrs-&gt;get(<span class="stringliteral">"name"</span>, name))
00262         <span class="keywordflow">throw</span> <a class="code" href="struct_f_i_x_1_1_config_error.html">ConfigError</a>(<span class="stringliteral">"&lt;field&gt; does not have a name attribute"</span>);
00263       std::string number;
00264       <span class="keywordflow">if</span>(!attrs-&gt;get(<span class="stringliteral">"number"</span>, number))
00265         <span class="keywordflow">throw</span> <a class="code" href="struct_f_i_x_1_1_config_error.html">ConfigError</a>(<span class="stringliteral">"&lt;field&gt; "</span> + name + <span class="stringliteral">" does not have a number attribute"</span>);
00266       <span class="keywordtype">int</span> num = atol(number.c_str());
00267       std::string type;
00268       <span class="keywordflow">if</span>(!attrs-&gt;get(<span class="stringliteral">"type"</span>, type))
00269         <span class="keywordflow">throw</span> <a class="code" href="struct_f_i_x_1_1_config_error.html">ConfigError</a>(<span class="stringliteral">"&lt;field&gt; "</span> + name + <span class="stringliteral">" does not have a type attribute"</span>);
00270       addField(num);
00271       addFieldType(num, XMLTypeToType(type));
00272       addFieldName(num, name);
00273 
00274       <a class="code" href="namespace_f_i_x.html#a79">DOMNodePtr</a> pFieldValueNode = pFieldNode-&gt;getFirstChildNode();
00275       <span class="keywordflow">while</span>(pFieldValueNode.get())
00276       {
00277         <span class="keywordflow">if</span>(pFieldValueNode-&gt;getName() == <span class="stringliteral">"value"</span>)
00278         {
00279           <a class="code" href="namespace_f_i_x.html#a78">DOMAttributesPtr</a> attrs = pFieldValueNode-&gt;getAttributes();
00280           std::string enumeration;
00281           <span class="keywordflow">if</span>(!attrs-&gt;get(<span class="stringliteral">"enum"</span>, enumeration))
00282             <span class="keywordflow">throw</span> <a class="code" href="struct_f_i_x_1_1_config_error.html">ConfigError</a>(<span class="stringliteral">"&lt;value&gt; does not have enum attribute in field "</span> + name);
00283           addFieldValue(num, enumeration);
00284           std::string description;
00285           <span class="keywordflow">if</span>(attrs-&gt;get(<span class="stringliteral">"description"</span>, description))
00286             addValueName(num, enumeration, description);
00287         }
00288         <a class="code" href="_data_dictionary_8cpp.html#a0">RESET_AUTO_PTR</a>(pFieldValueNode, pFieldValueNode-&gt;getNextSiblingNode());
00289       }
00290     }
00291     <a class="code" href="_data_dictionary_8cpp.html#a0">RESET_AUTO_PTR</a>(pFieldNode, pFieldNode-&gt;getNextSiblingNode());
00292   }
00293 
00294   <span class="comment">// HEADER</span>
00295   <a class="code" href="namespace_f_i_x.html#a79">DOMNodePtr</a> pHeaderNode = pDoc-&gt;getNode(<span class="stringliteral">"/fix/header"</span>);
00296   <span class="keywordflow">if</span>(!pHeaderNode.get())
00297     <span class="keywordflow">throw</span> <a class="code" href="struct_f_i_x_1_1_config_error.html">ConfigError</a>(<span class="stringliteral">"&lt;header&gt; section not found in data dictionary"</span>);
00298 
00299   <a class="code" href="namespace_f_i_x.html#a79">DOMNodePtr</a> pHeaderFieldNode = pHeaderNode-&gt;getFirstChildNode();
00300   <span class="keywordflow">if</span>(!pHeaderFieldNode.get()) <span class="keywordflow">throw</span> <a class="code" href="struct_f_i_x_1_1_config_error.html">ConfigError</a>(<span class="stringliteral">"No header fields defined"</span>);
00301 
00302   <span class="keywordflow">while</span>(pHeaderFieldNode.get())
00303   {
00304     <span class="keywordflow">if</span>(pHeaderFieldNode-&gt;getName() == <span class="stringliteral">"field"</span> || pHeaderFieldNode-&gt;getName() == <span class="stringliteral">"group"</span> )
00305     {
00306       <a class="code" href="namespace_f_i_x.html#a78">DOMAttributesPtr</a> attrs = pHeaderFieldNode-&gt;getAttributes();
00307       std::string name;
00308       <span class="keywordflow">if</span>(!attrs-&gt;get(<span class="stringliteral">"name"</span>, name))
00309         <span class="keywordflow">throw</span> <a class="code" href="struct_f_i_x_1_1_config_error.html">ConfigError</a>(<span class="stringliteral">"&lt;field&gt; does not have a name attribute"</span>);
00310       std::string required = <span class="stringliteral">"false"</span>;
00311       attrs-&gt;get(<span class="stringliteral">"required"</span>, required);
00312       addHeaderField(lookupXMLFieldNumber(pDoc.get(), name), required == <span class="stringliteral">"true"</span>);
00313     }
00314     <span class="keywordflow">if</span>(pHeaderFieldNode-&gt;getName() == <span class="stringliteral">"group"</span>)
00315     {
00316       <a class="code" href="namespace_f_i_x.html#a78">DOMAttributesPtr</a> attrs = pHeaderFieldNode-&gt;getAttributes();
00317       std::string required;
00318       attrs-&gt;get(<span class="stringliteral">"required"</span>, required);
00319       <span class="keywordtype">bool</span> isRequired = (required == <span class="stringliteral">"Y"</span> || required == <span class="stringliteral">"y"</span>);
00320       addXMLGroup(pDoc.get(), pHeaderFieldNode.get(), <span class="stringliteral">"_header_"</span>, *<span class="keyword">this</span>, isRequired);
00321     }
00322 
00323     <a class="code" href="_data_dictionary_8cpp.html#a0">RESET_AUTO_PTR</a>(pHeaderFieldNode, pHeaderFieldNode-&gt;getNextSiblingNode());
00324   }
00325 
00326   <span class="comment">// TRAILER</span>
00327   <a class="code" href="namespace_f_i_x.html#a79">DOMNodePtr</a> pTrailerNode = pDoc-&gt;getNode(<span class="stringliteral">"/fix/trailer"</span>);
00328   <span class="keywordflow">if</span>(!pTrailerNode.get())
00329     <span class="keywordflow">throw</span> <a class="code" href="struct_f_i_x_1_1_config_error.html">ConfigError</a>(<span class="stringliteral">"&lt;trailer&gt; section not found in data dictionary"</span>);
00330 
00331   <a class="code" href="namespace_f_i_x.html#a79">DOMNodePtr</a> pTrailerFieldNode = pTrailerNode-&gt;getFirstChildNode();
00332   <span class="keywordflow">if</span>(!pTrailerFieldNode.get()) <span class="keywordflow">throw</span> <a class="code" href="struct_f_i_x_1_1_config_error.html">ConfigError</a>(<span class="stringliteral">"No trailer fields defined"</span>);
00333 
00334   <span class="keywordflow">while</span>(pTrailerFieldNode.get())
00335   {
00336     <span class="keywordflow">if</span>(pTrailerFieldNode-&gt;getName() == <span class="stringliteral">"field"</span> || pTrailerFieldNode-&gt;getName() == <span class="stringliteral">"group"</span> )
00337     {
00338       <a class="code" href="namespace_f_i_x.html#a78">DOMAttributesPtr</a> attrs = pTrailerFieldNode-&gt;getAttributes();
00339       std::string name;
00340       <span class="keywordflow">if</span>(!attrs-&gt;get(<span class="stringliteral">"name"</span>, name))
00341         <span class="keywordflow">throw</span> <a class="code" href="struct_f_i_x_1_1_config_error.html">ConfigError</a>(<span class="stringliteral">"&lt;field&gt; does not have a name attribute"</span>);
00342       std::string required = <span class="stringliteral">"false"</span>;
00343       attrs-&gt;get(<span class="stringliteral">"required"</span>, required);
00344       addTrailerField(lookupXMLFieldNumber(pDoc.get(), name), required == <span class="stringliteral">"true"</span>);
00345     }
00346     <span class="keywordflow">if</span>(pTrailerFieldNode-&gt;getName() == <span class="stringliteral">"group"</span>)
00347     {
00348       <a class="code" href="namespace_f_i_x.html#a78">DOMAttributesPtr</a> attrs = pTrailerFieldNode-&gt;getAttributes();
00349       std::string required;
00350       attrs-&gt;get(<span class="stringliteral">"required"</span>, required);
00351       <span class="keywordtype">bool</span> isRequired = (required == <span class="stringliteral">"Y"</span> || required == <span class="stringliteral">"y"</span>);
00352       addXMLGroup(pDoc.get(), pTrailerFieldNode.get(), <span class="stringliteral">"_trailer_"</span>, *<span class="keyword">this</span>, isRequired);
00353     }
00354 
00355     <a class="code" href="_data_dictionary_8cpp.html#a0">RESET_AUTO_PTR</a>(pTrailerFieldNode, pTrailerFieldNode-&gt;getNextSiblingNode());
00356   }
00357 
00358   <span class="comment">// MSGTYPE</span>
00359   <a class="code" href="namespace_f_i_x.html#a79">DOMNodePtr</a> pMessagesNode = pDoc-&gt;getNode(<span class="stringliteral">"/fix/messages"</span>);
00360   <span class="keywordflow">if</span>(!pMessagesNode.get())
00361     <span class="keywordflow">throw</span> <a class="code" href="struct_f_i_x_1_1_config_error.html">ConfigError</a>(<span class="stringliteral">"&lt;messages&gt; section not found in data dictionary"</span>);
00362 
00363   <a class="code" href="namespace_f_i_x.html#a79">DOMNodePtr</a> pMessageNode = pMessagesNode-&gt;getFirstChildNode();
00364   <span class="keywordflow">if</span>(!pMessageNode.get()) <span class="keywordflow">throw</span> <a class="code" href="struct_f_i_x_1_1_config_error.html">ConfigError</a>(<span class="stringliteral">"No messages defined"</span>);
00365 
00366   <span class="keywordflow">while</span>(pMessageNode.get())
00367   {
00368     <span class="keywordflow">if</span>(pMessageNode-&gt;getName() == <span class="stringliteral">"message"</span>)
00369     {
00370       <a class="code" href="namespace_f_i_x.html#a78">DOMAttributesPtr</a> attrs = pMessageNode-&gt;getAttributes();
00371       std::string msgtype;
00372       <span class="keywordflow">if</span>(!attrs-&gt;get(<span class="stringliteral">"msgtype"</span>, msgtype))
00373         <span class="keywordflow">throw</span> <a class="code" href="struct_f_i_x_1_1_config_error.html">ConfigError</a>(<span class="stringliteral">"&lt;field&gt; does not have a name attribute"</span>);
00374       addMsgType(msgtype);
00375 
00376       std::string name;
00377       <span class="keywordflow">if</span>(attrs-&gt;get(<span class="stringliteral">"name"</span>, name))
00378         addValueName( 35, msgtype, name );
00379 
00380       <a class="code" href="namespace_f_i_x.html#a79">DOMNodePtr</a> pMessageFieldNode = pMessageNode-&gt;getFirstChildNode();
00381       <span class="keywordflow">if</span>( !pMessageFieldNode.get() )
00382         <span class="keywordflow">throw</span> <a class="code" href="struct_f_i_x_1_1_config_error.html">ConfigError</a>(<span class="stringliteral">"&lt;message&gt; contains no fields"</span>);
00383       <span class="keywordflow">while</span>( pMessageFieldNode.get() )
00384       {
00385         <span class="keywordflow">if</span>(pMessageFieldNode-&gt;getName() == <span class="stringliteral">"field"</span>
00386            || pMessageFieldNode-&gt;getName() == <span class="stringliteral">"group"</span>)
00387         {
00388           <a class="code" href="namespace_f_i_x.html#a78">DOMAttributesPtr</a> attrs = pMessageFieldNode-&gt;getAttributes();
00389           std::string name;
00390           <span class="keywordflow">if</span>(!attrs-&gt;get(<span class="stringliteral">"name"</span>, name))
00391             <span class="keywordflow">throw</span> <a class="code" href="struct_f_i_x_1_1_config_error.html">ConfigError</a>(<span class="stringliteral">"&lt;field&gt; does not have a name attribute"</span>);
00392           <span class="keywordtype">int</span> num = lookupXMLFieldNumber(pDoc.get(), name);
00393           addMsgField(msgtype, num);
00394 
00395           std::string required;
00396           <span class="keywordflow">if</span>(attrs-&gt;get(<span class="stringliteral">"required"</span>, required)
00397              &amp;&amp; (required == <span class="stringliteral">"Y"</span> || required == <span class="stringliteral">"y"</span>))
00398           {
00399             addRequiredField(msgtype, num);
00400           }
00401         }
00402         <span class="keywordflow">else</span> <span class="keywordflow">if</span>(pMessageFieldNode-&gt;getName() == <span class="stringliteral">"component"</span>)
00403         {
00404           <a class="code" href="namespace_f_i_x.html#a78">DOMAttributesPtr</a> attrs = pMessageFieldNode-&gt;getAttributes();
00405           std::string required;
00406           attrs-&gt;get(<span class="stringliteral">"required"</span>, required);
00407           <span class="keywordtype">bool</span> isRequired = (required == <span class="stringliteral">"Y"</span> || required == <span class="stringliteral">"y"</span>);
00408           addXMLComponentFields(pDoc.get(), pMessageFieldNode.get(),
00409                                 msgtype, *<span class="keyword">this</span>, isRequired);
00410         }
00411         <span class="keywordflow">if</span>(pMessageFieldNode-&gt;getName() == <span class="stringliteral">"group"</span>)
00412         {
00413           <a class="code" href="namespace_f_i_x.html#a78">DOMAttributesPtr</a> attrs = pMessageFieldNode-&gt;getAttributes();
00414           std::string required;
00415           attrs-&gt;get(<span class="stringliteral">"required"</span>, required);
00416           <span class="keywordtype">bool</span> isRequired = (required == <span class="stringliteral">"Y"</span> || required == <span class="stringliteral">"y"</span>);
00417           addXMLGroup(pDoc.get(), pMessageFieldNode.get(), msgtype, *<span class="keyword">this</span>, isRequired);
00418         }
00419         <a class="code" href="_data_dictionary_8cpp.html#a0">RESET_AUTO_PTR</a>(pMessageFieldNode,
00420                        pMessageFieldNode-&gt;getNextSiblingNode());
00421       }
00422     }
00423     <a class="code" href="_data_dictionary_8cpp.html#a0">RESET_AUTO_PTR</a>(pMessageNode, pMessageNode-&gt;getNextSiblingNode());
00424   }
00425 
00426   <a class="code" href="_call_stack_8h.html#a1">QF_STACK_POP</a>
00427 }
00428 
<a name="l00429"></a><a class="code" href="class_f_i_x_1_1_data_dictionary.html#a8">00429</a> <span class="keywordtype">int</span>* DataDictionary::getOrderedFields()<span class="keyword"> const</span>
00430 <span class="keyword"></span>{ <a class="code" href="_call_stack_8h.html#a0">QF_STACK_PUSH</a>(DataDictionary::getOrderedFields)
00431 
00432   <span class="keywordflow">if</span>( <a class="code" href="class_f_i_x_1_1_data_dictionary.html#r10">m_orderedFieldsArray</a> ) <span class="keywordflow">return</span> <a class="code" href="class_f_i_x_1_1_data_dictionary.html#r10">m_orderedFieldsArray</a>;
00433   <a class="code" href="class_f_i_x_1_1_data_dictionary.html#r10">m_orderedFieldsArray</a> = <span class="keyword">new</span> <span class="keywordtype">int</span>[<a class="code" href="class_f_i_x_1_1_data_dictionary.html#r9">m_orderedFields</a>.size() + 1];
00434 
00435   <span class="keywordtype">int</span>* i = <a class="code" href="class_f_i_x_1_1_data_dictionary.html#r10">m_orderedFieldsArray</a>;
00436   OrderedFields::const_iterator iter;
00437   <span class="keywordflow">for</span>( iter = <a class="code" href="class_f_i_x_1_1_data_dictionary.html#r9">m_orderedFields</a>.begin(); iter != <a class="code" href="class_f_i_x_1_1_data_dictionary.html#r9">m_orderedFields</a>.end(); *(i++) = *(iter++) ) {}
00438   *i = 0;
00439   <span class="keywordflow">return</span> m_orderedFieldsArray;
00440 
00441   <a class="code" href="_call_stack_8h.html#a1">QF_STACK_POP</a>
00442 }
00443 
<a name="l00444"></a><a class="code" href="class_f_i_x_1_1_data_dictionary.html#d13">00444</a> <span class="keywordtype">int</span> DataDictionary::lookupXMLFieldNumber( <a class="code" href="class_f_i_x_1_1_d_o_m_document.html">DOMDocument</a>* pDoc, <a class="code" href="class_f_i_x_1_1_d_o_m_node.html">DOMNode</a>* pNode )<span class="keyword"> const</span>
00445 <span class="keyword"></span>{ <a class="code" href="_call_stack_8h.html#a0">QF_STACK_PUSH</a>(DataDictionary::lookupXMLFieldNumber)
00446 
00447   <a class="code" href="namespace_f_i_x.html#a78">DOMAttributesPtr</a> attrs = pNode-&gt;<a class="code" href="class_f_i_x_1_1_d_o_m_node.html#a3">getAttributes</a>();
00448   std::string name;
00449   <span class="keywordflow">if</span>(!attrs-&gt;get(<span class="stringliteral">"name"</span>, name))
00450     <span class="keywordflow">throw</span> <a class="code" href="struct_f_i_x_1_1_config_error.html">ConfigError</a>(<span class="stringliteral">"No name given to field"</span>);
00451   <span class="keywordflow">return</span> <a class="code" href="class_f_i_x_1_1_data_dictionary.html#d13">lookupXMLFieldNumber</a>( pDoc, name );
00452 
00453   <a class="code" href="_call_stack_8h.html#a1">QF_STACK_POP</a>
00454 }
00455 
00456 <span class="keywordtype">int</span> DataDictionary::lookupXMLFieldNumber
<a name="l00457"></a><a class="code" href="class_f_i_x_1_1_data_dictionary.html#d14">00457</a> ( <a class="code" href="class_f_i_x_1_1_d_o_m_document.html">DOMDocument</a>* pDoc, <span class="keyword">const</span> std::string&amp; name ) <span class="keyword">const</span>
00458 { <a class="code" href="_call_stack_8h.html#a0">QF_STACK_PUSH</a>(DataDictionary::lookupXMLFieldNumber)
00459 
00460   NameToField::const_iterator i = m_names.find(name);
00461   <span class="keywordflow">if</span>( i == m_names.end() )
00462     <span class="keywordflow">throw</span> <a class="code" href="struct_f_i_x_1_1_config_error.html">ConfigError</a>(<span class="stringliteral">"Field "</span> + name + <span class="stringliteral">" not defined in fields section"</span>);
00463   <span class="keywordflow">return</span> i-&gt;second;
00464 
00465   <a class="code" href="_call_stack_8h.html#a1">QF_STACK_POP</a>
00466 }
00467 
<a name="l00468"></a><a class="code" href="class_f_i_x_1_1_data_dictionary.html#d15">00468</a> <span class="keywordtype">int</span> DataDictionary::addXMLComponentFields( <a class="code" href="class_f_i_x_1_1_d_o_m_document.html">DOMDocument</a>* pDoc, <a class="code" href="class_f_i_x_1_1_d_o_m_node.html">DOMNode</a>* pNode,
00469                                             <span class="keyword">const</span> std::string&amp; msgtype,
00470                                             <a class="code" href="class_f_i_x_1_1_data_dictionary.html">DataDictionary</a>&amp; DD,
00471                                             <span class="keywordtype">bool</span> componentRequired )
00472 { <a class="code" href="_call_stack_8h.html#a0">QF_STACK_PUSH</a>(DataDictionary::addXMLComponentFields)
00473 
00474   <span class="keywordtype">int</span> firstField = 0;
00475 
00476   <a class="code" href="namespace_f_i_x.html#a78">DOMAttributesPtr</a> attrs = pNode-&gt;<a class="code" href="class_f_i_x_1_1_d_o_m_node.html#a3">getAttributes</a>();
00477   std::string name;
00478   <span class="keywordflow">if</span>(!attrs-&gt;get(<span class="stringliteral">"name"</span>, name))
00479     <span class="keywordflow">throw</span> <a class="code" href="struct_f_i_x_1_1_config_error.html">ConfigError</a>(<span class="stringliteral">"No name given to component"</span>);
00480 
00481   <a class="code" href="namespace_f_i_x.html#a79">DOMNodePtr</a> pComponentNode =
00482     pDoc-&gt;<a class="code" href="class_f_i_x_1_1_d_o_m_document.html#a4">getNode</a>(<span class="stringliteral">"/fix/components/component[@name='"</span> + name + <span class="stringliteral">"']"</span>);
00483   <span class="keywordflow">if</span>(pComponentNode.get() == 0)
00484     <span class="keywordflow">throw</span> <a class="code" href="struct_f_i_x_1_1_config_error.html">ConfigError</a>(<span class="stringliteral">"Component not found"</span>);
00485 
00486   <a class="code" href="namespace_f_i_x.html#a79">DOMNodePtr</a> pComponentFieldNode = pComponentNode-&gt;getFirstChildNode();
00487   <span class="keywordflow">while</span>(pComponentFieldNode.get())
00488   {
00489     <span class="keywordflow">if</span>(pComponentFieldNode-&gt;getName() == <span class="stringliteral">"field"</span>
00490        || pComponentFieldNode-&gt;getName() == <span class="stringliteral">"group"</span>)
00491     {
00492       <a class="code" href="namespace_f_i_x.html#a78">DOMAttributesPtr</a> attrs = pComponentFieldNode-&gt;getAttributes();
00493       std::string name;
00494       <span class="keywordflow">if</span>(!attrs-&gt;get(<span class="stringliteral">"name"</span>, name))
00495         <span class="keywordflow">throw</span> <a class="code" href="struct_f_i_x_1_1_config_error.html">ConfigError</a>(<span class="stringliteral">"No name given to field"</span>);
00496       <span class="keywordtype">int</span> field = <a class="code" href="class_f_i_x_1_1_data_dictionary.html#d13">lookupXMLFieldNumber</a>(pDoc, name);
00497       <span class="keywordflow">if</span>( firstField == 0 ) firstField = field;
00498 
00499       std::string required;
00500       <span class="keywordflow">if</span>(attrs-&gt;get(<span class="stringliteral">"required"</span>, required)
00501          &amp;&amp; (required == <span class="stringliteral">"Y"</span> || required ==<span class="stringliteral">"y"</span>)
00502          &amp;&amp; componentRequired)
00503       {
00504         <a class="code" href="class_f_i_x_1_1_data_dictionary.html#a28">addRequiredField</a>(msgtype, field);
00505       }
00506 
00507       DD.<a class="code" href="class_f_i_x_1_1_data_dictionary.html#a11">addField</a>(field);
00508       DD.<a class="code" href="class_f_i_x_1_1_data_dictionary.html#a20">addMsgField</a>(msgtype, field);
00509     }
00510     <span class="keywordflow">if</span>(pComponentFieldNode-&gt;getName() == <span class="stringliteral">"group"</span>)
00511     {
00512       <a class="code" href="namespace_f_i_x.html#a78">DOMAttributesPtr</a> attrs = pComponentFieldNode-&gt;getAttributes();
00513       std::string required;
00514       attrs-&gt;get(<span class="stringliteral">"required"</span>, required);
00515       <span class="keywordtype">bool</span> isRequired = (required == <span class="stringliteral">"Y"</span> || required == <span class="stringliteral">"y"</span>);
00516       <a class="code" href="class_f_i_x_1_1_data_dictionary.html#d16">addXMLGroup</a>(pDoc, pComponentFieldNode.get(), msgtype, DD, isRequired);
00517     }
00518     <a class="code" href="_data_dictionary_8cpp.html#a0">RESET_AUTO_PTR</a>(pComponentFieldNode,
00519       pComponentFieldNode-&gt;getNextSiblingNode());
00520   }
00521   <span class="keywordflow">return</span> firstField;
00522 
00523   <a class="code" href="_call_stack_8h.html#a1">QF_STACK_POP</a>
00524 }
00525 
<a name="l00526"></a><a class="code" href="class_f_i_x_1_1_data_dictionary.html#d16">00526</a> <span class="keywordtype">void</span> DataDictionary::addXMLGroup( <a class="code" href="class_f_i_x_1_1_d_o_m_document.html">DOMDocument</a>* pDoc, <a class="code" href="class_f_i_x_1_1_d_o_m_node.html">DOMNode</a>* pNode,
00527                                   <span class="keyword">const</span> std::string&amp; msgtype,
00528                                   <a class="code" href="class_f_i_x_1_1_data_dictionary.html">DataDictionary</a>&amp; DD, <span class="keywordtype">bool</span> groupRequired  )
00529 { <a class="code" href="_call_stack_8h.html#a0">QF_STACK_PUSH</a>(DataDictionary::addXMLGroup)
00530 
00531   <a class="code" href="namespace_f_i_x.html#a78">DOMAttributesPtr</a> attrs = pNode-&gt;<a class="code" href="class_f_i_x_1_1_d_o_m_node.html#a3">getAttributes</a>();
00532   std::string name;
00533   <span class="keywordflow">if</span>(!attrs-&gt;get(<span class="stringliteral">"name"</span>, name))
00534     <span class="keywordflow">throw</span> <a class="code" href="struct_f_i_x_1_1_config_error.html">ConfigError</a>(<span class="stringliteral">"No name given to group"</span>);
00535   <span class="keywordtype">int</span> group = <a class="code" href="class_f_i_x_1_1_data_dictionary.html#d13">lookupXMLFieldNumber</a>( pDoc, name );
00536   <span class="keywordtype">int</span> delim = 0;
00537   <span class="keywordtype">int</span> field = 0;
00538   <a class="code" href="class_f_i_x_1_1_data_dictionary.html">DataDictionary</a> groupDD;
00539   <a class="code" href="namespace_f_i_x.html#a79">DOMNodePtr</a> node = pNode-&gt;<a class="code" href="class_f_i_x_1_1_d_o_m_node.html#a1">getFirstChildNode</a>();
00540   <span class="keywordflow">while</span>(node.get())
00541   {
00542     <span class="keywordflow">if</span>( node-&gt;getName() == <span class="stringliteral">"field"</span> )
00543     {
00544       field = <a class="code" href="class_f_i_x_1_1_data_dictionary.html#d13">lookupXMLFieldNumber</a>( pDoc, node.get() );
00545       groupDD.<a class="code" href="class_f_i_x_1_1_data_dictionary.html#a11">addField</a>( field );
00546 
00547       <a class="code" href="namespace_f_i_x.html#a78">DOMAttributesPtr</a> attrs = node-&gt;getAttributes();
00548       std::string required;
00549       <span class="keywordflow">if</span>( attrs-&gt;get(<span class="stringliteral">"required"</span>, required)
00550          &amp;&amp; ( required == <span class="stringliteral">"Y"</span> || required ==<span class="stringliteral">"y"</span> )
00551          &amp;&amp; groupRequired )
00552       {
00553         groupDD.<a class="code" href="class_f_i_x_1_1_data_dictionary.html#a28">addRequiredField</a>(msgtype, field);
00554       }
00555     }
00556     <span class="keywordflow">else</span> <span class="keywordflow">if</span>( node-&gt;getName() == <span class="stringliteral">"component"</span> )
00557     {
00558       field = <a class="code" href="class_f_i_x_1_1_data_dictionary.html#d15">addXMLComponentFields</a>( pDoc, node.get(), msgtype, groupDD, <span class="keyword">false</span> );
00559     }
00560     <span class="keywordflow">else</span> <span class="keywordflow">if</span>( node-&gt;getName() == <span class="stringliteral">"group"</span> )
00561     {
00562       field = <a class="code" href="class_f_i_x_1_1_data_dictionary.html#d13">lookupXMLFieldNumber</a>( pDoc, node.get() );
00563       groupDD.<a class="code" href="class_f_i_x_1_1_data_dictionary.html#a11">addField</a>( field );
00564       <a class="code" href="namespace_f_i_x.html#a78">DOMAttributesPtr</a> attrs = node-&gt;getAttributes();
00565       std::string required;
00566       <span class="keywordflow">if</span>( attrs-&gt;get(<span class="stringliteral">"required"</span>, required )
00567          &amp;&amp; ( required == <span class="stringliteral">"Y"</span> || required ==<span class="stringliteral">"y"</span> )
00568          &amp;&amp; groupRequired)
00569       {
00570         groupDD.<a class="code" href="class_f_i_x_1_1_data_dictionary.html#a28">addRequiredField</a>(msgtype, field);
00571       }
00572             <span class="keywordtype">bool</span> isRequired = <span class="keyword">false</span>;
00573             <span class="keywordflow">if</span>( attrs-&gt;get(<span class="stringliteral">"required"</span>, required) )
00574                   isRequired = (required == <span class="stringliteral">"Y"</span> || required == <span class="stringliteral">"y"</span>);
00575       <a class="code" href="class_f_i_x_1_1_data_dictionary.html#d16">addXMLGroup</a>( pDoc, node.get(), msgtype, groupDD, isRequired );
00576     }
00577     <span class="keywordflow">if</span>( delim == 0 ) delim = field;
00578     <a class="code" href="_data_dictionary_8cpp.html#a0">RESET_AUTO_PTR</a>(node, node-&gt;getNextSiblingNode());
00579   }
00580 
00581   <span class="keywordflow">if</span>( delim ) DD.<a class="code" href="class_f_i_x_1_1_data_dictionary.html#a33">addGroup</a>( msgtype, group, delim, groupDD );
00582 
00583   <a class="code" href="_call_stack_8h.html#a1">QF_STACK_POP</a>
00584 }
00585 
<a name="l00586"></a><a class="code" href="class_f_i_x_1_1_data_dictionary.html#d17">00586</a> TYPE::Type DataDictionary::XMLTypeToType( <span class="keyword">const</span> std::string&amp; type )<span class="keyword"> const</span>
00587 <span class="keyword"></span>{ <a class="code" href="_call_stack_8h.html#a0">QF_STACK_PUSH</a>(DataDictionary::XMLTypeToType)
00588 
00589   <span class="keywordflow">if</span> ( <a class="code" href="class_f_i_x_1_1_data_dictionary.html#r4">m_beginString</a> &lt; <span class="stringliteral">"FIX.4.2"</span> &amp;&amp; type == <span class="stringliteral">"CHAR"</span> )
00590     <span class="keywordflow">return</span> TYPE::String;
00591 
00592   <span class="keywordflow">if</span> ( type == <span class="stringliteral">"STRING"</span> ) <span class="keywordflow">return</span> TYPE::String;
00593   <span class="keywordflow">if</span> ( type == <span class="stringliteral">"CHAR"</span> ) <span class="keywordflow">return</span> TYPE::Char;
00594   <span class="keywordflow">if</span> ( type == <span class="stringliteral">"PRICE"</span> ) <span class="keywordflow">return</span> TYPE::Price;
00595   <span class="keywordflow">if</span> ( type == <span class="stringliteral">"INT"</span> ) <span class="keywordflow">return</span> TYPE::Int;
00596   <span class="keywordflow">if</span> ( type == <span class="stringliteral">"AMT"</span> ) <span class="keywordflow">return</span> TYPE::Amt;
00597   <span class="keywordflow">if</span> ( type == <span class="stringliteral">"QTY"</span> ) <span class="keywordflow">return</span> TYPE::Qty;
00598   <span class="keywordflow">if</span> ( type == <span class="stringliteral">"CURRENCY"</span> ) <span class="keywordflow">return</span> TYPE::Currency;
00599   <span class="keywordflow">if</span> ( type == <span class="stringliteral">"MULTIPLEVALUESTRING"</span> ) <span class="keywordflow">return</span> TYPE::MultipleValueString;
00600   <span class="keywordflow">if</span> ( type == <span class="stringliteral">"EXCHANGE"</span> ) <span class="keywordflow">return</span> TYPE::Exchange;
00601   <span class="keywordflow">if</span> ( type == <span class="stringliteral">"UTCTIMESTAMP"</span> ) <span class="keywordflow">return</span> TYPE::UtcTimeStamp;
00602   <span class="keywordflow">if</span> ( type == <span class="stringliteral">"BOOLEAN"</span> ) <span class="keywordflow">return</span> TYPE::Boolean;
00603   <span class="keywordflow">if</span> ( type == <span class="stringliteral">"LOCALMKTDATE"</span> ) <span class="keywordflow">return</span> TYPE::LocalMktDate;
00604   <span class="keywordflow">if</span> ( type == <span class="stringliteral">"DATA"</span> ) <span class="keywordflow">return</span> TYPE::Data;
00605   <span class="keywordflow">if</span> ( type == <span class="stringliteral">"FLOAT"</span> ) <span class="keywordflow">return</span> TYPE::Float;
00606   <span class="keywordflow">if</span> ( type == <span class="stringliteral">"PRICEOFFSET"</span> ) <span class="keywordflow">return</span> TYPE::PriceOffset;
00607   <span class="keywordflow">if</span> ( type == <span class="stringliteral">"MONTHYEAR"</span> ) <span class="keywordflow">return</span> TYPE::MonthYear;
00608   <span class="keywordflow">if</span> ( type == <span class="stringliteral">"DAYOFMONTH"</span> ) <span class="keywordflow">return</span> TYPE::DayOfMonth;
00609   <span class="keywordflow">if</span> ( type == <span class="stringliteral">"UTCDATE"</span> ) <span class="keywordflow">return</span> TYPE::UtcDate;
00610   <span class="keywordflow">if</span> ( type == <span class="stringliteral">"UTCDATEONLY"</span> ) <span class="keywordflow">return</span> TYPE::UtcDateOnly;
00611   <span class="keywordflow">if</span> ( type == <span class="stringliteral">"UTCTIMEONLY"</span> ) <span class="keywordflow">return</span> TYPE::UtcTimeOnly;
00612   <span class="keywordflow">if</span> ( type == <span class="stringliteral">"NUMINGROUP"</span> ) <span class="keywordflow">return</span> TYPE::NumInGroup;
00613   <span class="keywordflow">if</span> ( type == <span class="stringliteral">"PERCENTAGE"</span> ) <span class="keywordflow">return</span> TYPE::Percentage;
00614   <span class="keywordflow">if</span> ( type == <span class="stringliteral">"SEQNUM"</span> ) <span class="keywordflow">return</span> TYPE::SeqNum;
00615   <span class="keywordflow">if</span> ( type == <span class="stringliteral">"LENGTH"</span> ) <span class="keywordflow">return</span> TYPE::Length;
00616   <span class="keywordflow">if</span> ( type == <span class="stringliteral">"COUNTRY"</span> ) <span class="keywordflow">return</span> TYPE::Country;
00617   <span class="keywordflow">if</span> ( type == <span class="stringliteral">"TIME"</span> ) <span class="keywordflow">return</span> TYPE::UtcTimeStamp;
00618   <span class="keywordflow">return</span> TYPE::Unknown;
00619 
00620   <a class="code" href="_call_stack_8h.html#a1">QF_STACK_POP</a>
00621 }
00622 }
</pre></div><hr><address><small>
Generated on Thu Sep 14 08:52:33 2006 for QuickFIX by <a href="http://www.doxygen.org/index.html">
<img src="doxygen.gif" alt="doxygen" align="middle" border=0 width=110 height=53>
</a> 1.3.6-20040222 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,
 &copy;&nbsp;1997-2001</small></address>
</body>
</html>
