<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>/home/orenmnero/autobuild/quickfix/src/C++/ThreadedSocketAcceptor.cpp Source File</title>
<link href="quickfix.css" rel="stylesheet" type="text/css">
<table cellspacing="0" cellpadding="0" border="0">
  <tr>
   <td><img src="images/outsideTopLeft.gif"></td>
   <td width="100%" class="outsideTop">&nbsp;</td>
   <td><img src="images/outsideTopRight.gif"></td>
  </tr>
  <tr>
   <td class="outsideLeft">&nbsp;</td>
   <td>
	<img src="images/QuickFIX.jpg" align="middle" border=0>
	&nbsp;&nbsp;
	<a href="index.html">Index</a>&nbsp;
	<a href="files.html">Source Files</a>&nbsp;
	<a href="annotated.html">Annotated Class List</a>&nbsp;
	<a href="classes.html">Alphabetical Class List</a>&nbsp;
	<a href="hierarchy.html">Class Hierarchy</a>&nbsp;
	<a href="inherits.html">Graphical Class Hierarchy</a>&nbsp;
   </td>
   <td class="outsideRight">&nbsp;</td>
  </tr>
  <tr>
   <td><img src="images/outsideBottomLeft.gif"></td>
   <td width=100% class="outsideBottom">&nbsp;</td>
   <td><img src="images/outsideBottomRight.gif"></td>
  </tr>
</table>
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.3.6-20040222 -->
<h1>/home/orenmnero/autobuild/quickfix/src/C++/ThreadedSocketAcceptor.cpp</h1><a href="_threaded_socket_acceptor_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/****************************************************************************</span>
00002 <span class="comment">** Copyright (c) quickfixengine.org  All rights reserved.</span>
00003 <span class="comment">**</span>
00004 <span class="comment">** This file is part of the QuickFIX FIX Engine</span>
00005 <span class="comment">**</span>
00006 <span class="comment">** This file may be distributed under the terms of the quickfixengine.org</span>
00007 <span class="comment">** license as defined by quickfixengine.org and appearing in the file</span>
00008 <span class="comment">** LICENSE included in the packaging of this file.</span>
00009 <span class="comment">**</span>
00010 <span class="comment">** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE</span>
00011 <span class="comment">** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.</span>
00012 <span class="comment">**</span>
00013 <span class="comment">** See http://www.quickfixengine.org/LICENSE for licensing information.</span>
00014 <span class="comment">**</span>
00015 <span class="comment">** Contact ask@quickfixengine.org if any conditions of this licensing are</span>
00016 <span class="comment">** not clear to you.</span>
00017 <span class="comment">**</span>
00018 <span class="comment">****************************************************************************/</span>
00019 
00020 <span class="preprocessor">#ifdef _MSC_VER</span>
00021 <span class="preprocessor"></span><span class="preprocessor">#include "stdafx.h"</span>
00022 <span class="preprocessor">#else</span>
00023 <span class="preprocessor"></span><span class="preprocessor">#include "config.h"</span>
00024 <span class="preprocessor">#endif</span>
00025 <span class="preprocessor"></span><span class="preprocessor">#include "<a class="code" href="_call_stack_8h.html">CallStack.h</a>"</span>
00026 
00027 <span class="preprocessor">#include "<a class="code" href="_threaded_socket_acceptor_8h.html">ThreadedSocketAcceptor.h</a>"</span>
00028 <span class="preprocessor">#include "<a class="code" href="_settings_8h.html">Settings.h</a>"</span>
00029 <span class="preprocessor">#include "<a class="code" href="_utility_8h.html">Utility.h</a>"</span>
00030 
00031 <span class="keyword">namespace </span>FIX
00032 {
<a name="l00033"></a><a class="code" href="class_f_i_x_1_1_threaded_socket_acceptor.html#a0">00033</a> ThreadedSocketAcceptor::ThreadedSocketAcceptor(
00034   <a class="code" href="class_f_i_x_1_1_application.html">Application</a>&amp; application,
00035   <a class="code" href="class_f_i_x_1_1_message_store_factory.html">MessageStoreFactory</a>&amp; factory,
00036   <span class="keyword">const</span> <a class="code" href="class_f_i_x_1_1_session_settings.html">SessionSettings</a>&amp; settings ) <span class="keywordflow">throw</span>( <a class="code" href="struct_f_i_x_1_1_config_error.html">ConfigError</a> )
00037 : <a class="code" href="class_f_i_x_1_1_acceptor.html">Acceptor</a>( application, factory, settings )
00038 { <a class="code" href="namespace_f_i_x.html#a2913">socket_init</a>(); }
00039 
<a name="l00040"></a><a class="code" href="class_f_i_x_1_1_threaded_socket_acceptor.html#a1">00040</a> ThreadedSocketAcceptor::ThreadedSocketAcceptor(
00041   <a class="code" href="class_f_i_x_1_1_application.html">Application</a>&amp; application,
00042   <a class="code" href="class_f_i_x_1_1_message_store_factory.html">MessageStoreFactory</a>&amp; factory,
00043   <span class="keyword">const</span> <a class="code" href="class_f_i_x_1_1_session_settings.html">SessionSettings</a>&amp; settings,
00044   <a class="code" href="class_f_i_x_1_1_log_factory.html">LogFactory</a>&amp; logFactory ) <span class="keywordflow">throw</span>( <a class="code" href="struct_f_i_x_1_1_config_error.html">ConfigError</a> )
00045 : <a class="code" href="class_f_i_x_1_1_acceptor.html">Acceptor</a>( application, factory, settings, logFactory )
00046 { 
00047   <a class="code" href="namespace_f_i_x.html#a2913">socket_init</a>(); 
00048 }
00049 
<a name="l00050"></a><a class="code" href="class_f_i_x_1_1_threaded_socket_acceptor.html#a2">00050</a> ThreadedSocketAcceptor::~ThreadedSocketAcceptor()
00051 { 
00052   <a class="code" href="namespace_f_i_x.html#a2914">socket_term</a>(); 
00053 }
00054 
<a name="l00055"></a><a class="code" href="class_f_i_x_1_1_threaded_socket_acceptor.html#d1">00055</a> <span class="keywordtype">void</span> ThreadedSocketAcceptor::onConfigure( <span class="keyword">const</span> <a class="code" href="class_f_i_x_1_1_session_settings.html">SessionSettings</a>&amp; s )
00056 <span class="keywordflow">throw</span> ( <a class="code" href="struct_f_i_x_1_1_config_error.html">ConfigError</a> )
00057 { <a class="code" href="_call_stack_8h.html#a0">QF_STACK_PUSH</a>(ThreadedSocketAcceptor::onConfigure)
00058 
00059   std::set&lt;SessionID&gt; sessions = s.getSessions();
00060   std::set&lt;SessionID&gt;::iterator i;
00061   <span class="keywordflow">for</span>( i = sessions.begin(); i != sessions.end(); ++i )
00062   {
00063     <span class="keyword">const</span> <a class="code" href="class_f_i_x_1_1_dictionary.html">Dictionary</a>&amp; settings = s.get( *i );
00064     settings.<a class="code" href="class_f_i_x_1_1_dictionary.html#a6">getLong</a>( <a class="code" href="namespace_f_i_x.html#a174">SOCKET_ACCEPT_PORT</a> );
00065     <span class="keywordflow">if</span>( settings.<a class="code" href="class_f_i_x_1_1_dictionary.html#a15">has</a>(<a class="code" href="namespace_f_i_x.html#a175">SOCKET_REUSE_ADDRESS</a>) )
00066       settings.<a class="code" href="class_f_i_x_1_1_dictionary.html#a8">getBool</a>( <a class="code" href="namespace_f_i_x.html#a175">SOCKET_REUSE_ADDRESS</a> );
00067     <span class="keywordflow">if</span>( settings.<a class="code" href="class_f_i_x_1_1_dictionary.html#a15">has</a>(<a class="code" href="namespace_f_i_x.html#a178">SOCKET_NODELAY</a>) )
00068       settings.<a class="code" href="class_f_i_x_1_1_dictionary.html#a8">getBool</a>( <a class="code" href="namespace_f_i_x.html#a178">SOCKET_NODELAY</a> );
00069   }
00070 
00071   <a class="code" href="_call_stack_8h.html#a1">QF_STACK_POP</a>
00072 }
00073 
<a name="l00074"></a><a class="code" href="class_f_i_x_1_1_threaded_socket_acceptor.html#d2">00074</a> <span class="keywordtype">void</span> ThreadedSocketAcceptor::onInitialize( <span class="keyword">const</span> <a class="code" href="class_f_i_x_1_1_session_settings.html">SessionSettings</a>&amp; s )
00075 <span class="keywordflow">throw</span> ( <a class="code" href="struct_f_i_x_1_1_runtime_error.html">RuntimeError</a> )
00076 { <a class="code" href="_call_stack_8h.html#a0">QF_STACK_PUSH</a>(ThreadedSocketAcceptor::onInitialize)
00077 
00078   <span class="keywordtype">short</span> port = 0;
00079   <span class="keywordtype">bool</span> reuseAddress = <span class="keyword">false</span>;
00080   <span class="keywordtype">bool</span> noDelay = <span class="keyword">false</span>;
00081 
00082   std::set&lt;int&gt; ports;
00083 
00084   std::set&lt;SessionID&gt; sessions = s.getSessions();
00085   std::set&lt;SessionID&gt;::iterator i = sessions.begin();
00086   <span class="keywordflow">for</span>( ; i != sessions.end(); ++i )
00087   {
00088     <a class="code" href="class_f_i_x_1_1_dictionary.html">Dictionary</a> settings = s.get( *i );
00089     port = (<span class="keywordtype">short</span>)settings.<a class="code" href="class_f_i_x_1_1_dictionary.html#a6">getLong</a>( <a class="code" href="namespace_f_i_x.html#a174">SOCKET_ACCEPT_PORT</a> );
00090 
00091     m_portToSessions[port].insert( *i );
00092 
00093     <span class="keywordflow">if</span>( ports.find(port) != ports.end() )
00094       <span class="keywordflow">continue</span>;
00095     ports.insert( port );
00096 
00097     <span class="keywordflow">if</span>( settings.<a class="code" href="class_f_i_x_1_1_dictionary.html#a15">has</a>( <a class="code" href="namespace_f_i_x.html#a175">SOCKET_REUSE_ADDRESS</a> ) )
00098       reuseAddress = s.get().getBool( <a class="code" href="namespace_f_i_x.html#a175">SOCKET_REUSE_ADDRESS</a> );
00099     <span class="keywordflow">if</span>( settings.<a class="code" href="class_f_i_x_1_1_dictionary.html#a15">has</a>( <a class="code" href="namespace_f_i_x.html#a178">SOCKET_NODELAY</a> ) )
00100       noDelay = s.get().getBool( <a class="code" href="namespace_f_i_x.html#a178">SOCKET_NODELAY</a> );
00101 
00102     <span class="keywordtype">int</span> socket = <a class="code" href="namespace_f_i_x.html#a2915">socket_createAcceptor</a>( port, reuseAddress );
00103     <span class="keywordflow">if</span>( socket &lt; 0 )
00104     {
00105       <a class="code" href="struct_f_i_x_1_1_socket_exception.html">SocketException</a> e;
00106       <a class="code" href="namespace_f_i_x.html#a2920">socket_close</a>( socket );
00107       <span class="keywordflow">throw</span> <a class="code" href="struct_f_i_x_1_1_runtime_error.html">RuntimeError</a>( <span class="stringliteral">"Unable to create, bind, or listen to port "</span> 
00108                          + IntConvertor::convert( (<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>)port ) + <span class="stringliteral">" ("</span> + e.what() + <span class="stringliteral">")"</span> );
00109     }
00110     <span class="keywordflow">if</span>( noDelay )
00111       <a class="code" href="namespace_f_i_x.html#a2923">socket_setsockopt</a>( socket, TCP_NODELAY );
00112 
00113     m_socketToPort[socket] = port;
00114     m_sockets.insert( socket );
00115   }    
00116 
00117   <a class="code" href="_call_stack_8h.html#a1">QF_STACK_POP</a>
00118 }
00119 
<a name="l00120"></a><a class="code" href="class_f_i_x_1_1_threaded_socket_acceptor.html#d3">00120</a> <span class="keywordtype">void</span> ThreadedSocketAcceptor::onStart()
00121 { <a class="code" href="_call_stack_8h.html#a0">QF_STACK_PUSH</a>(ThreadedSocketAcceptor::onStart)
00122 
00123   Sockets::iterator i;
00124   <span class="keywordflow">for</span>( i = m_sockets.begin(); i != m_sockets.end(); ++i )
00125   {
00126     <a class="code" href="class_f_i_x_1_1_locker.html">Locker</a> l( m_mutex );
00127     <span class="keywordtype">int</span> port = <a class="code" href="class_f_i_x_1_1_threaded_socket_acceptor.html#r2">m_socketToPort</a>[*i];
00128     <a class="code" href="struct_f_i_x_1_1_threaded_socket_acceptor_1_1_acceptor_thread_info.html">AcceptorThreadInfo</a>* info = <span class="keyword">new</span> <a class="code" href="struct_f_i_x_1_1_threaded_socket_acceptor_1_1_acceptor_thread_info.html">AcceptorThreadInfo</a>( <span class="keyword">this</span>, *i, port );
00129     <span class="keywordtype">unsigned</span> thread;
00130     <a class="code" href="namespace_f_i_x.html#a2939">thread_spawn</a>( &amp;<a class="code" href="class_f_i_x_1_1_threaded_socket_acceptor.html#h0">socketAcceptorThread</a>, info, thread );
00131     <a class="code" href="class_f_i_x_1_1_threaded_socket_acceptor.html#d6">addThread</a>( *i, thread );
00132   }
00133 
00134   <a class="code" href="_call_stack_8h.html#a1">QF_STACK_POP</a>
00135 }
00136 
<a name="l00137"></a><a class="code" href="class_f_i_x_1_1_threaded_socket_acceptor.html#d4">00137</a> <span class="keywordtype">bool</span> ThreadedSocketAcceptor::onPoll()
00138 { <a class="code" href="_call_stack_8h.html#a0">QF_STACK_PUSH</a>(ThreadedSocketAcceptor::onPoll)
00139 
00140   <span class="keywordflow">return</span> <span class="keyword">false</span>;
00141 
00142   <a class="code" href="_call_stack_8h.html#a1">QF_STACK_POP</a>
00143 }
00144 
<a name="l00145"></a><a class="code" href="class_f_i_x_1_1_threaded_socket_acceptor.html#d5">00145</a> <span class="keywordtype">void</span> ThreadedSocketAcceptor::onStop()
00146 { <a class="code" href="_call_stack_8h.html#a0">QF_STACK_PUSH</a>(ThreadedSocketAcceptor::onStop)
00147 
00148   <a class="code" href="class_f_i_x_1_1_locker.html">Locker</a> l(m_mutex);
00149 
00150   time_t start = 0;
00151   time_t now = 0;
00152 
00153   ::time( &amp;start );
00154   <span class="keywordflow">while</span> ( <a class="code" href="class_f_i_x_1_1_acceptor.html#a7">isLoggedOn</a>() )
00155   {
00156     <span class="keywordflow">if</span>( ::time(&amp;now) -5 &gt;= start )
00157       <span class="keywordflow">break</span>;
00158   }
00159 
00160   <a class="code" href="class_f_i_x_1_1_threaded_socket_acceptor.html#y4">SocketToThread</a> threads;
00161   threads = <a class="code" href="class_f_i_x_1_1_threaded_socket_acceptor.html#r3">m_threads</a>;
00162 
00163   SocketToThread::iterator i;
00164   <span class="keywordflow">for</span> ( i = threads.begin(); i != threads.end(); ++i )
00165     <a class="code" href="namespace_f_i_x.html#a2920">socket_close</a>( i-&gt;first );
00166   <span class="keywordflow">for</span> ( i = threads.begin(); i != threads.end(); ++i )
00167     <a class="code" href="namespace_f_i_x.html#a2941">thread_join</a>( i-&gt;second );
00168   threads.clear();
00169 
00170   <a class="code" href="_call_stack_8h.html#a1">QF_STACK_POP</a>
00171 }
00172 
<a name="l00173"></a><a class="code" href="class_f_i_x_1_1_threaded_socket_acceptor.html#d6">00173</a> <span class="keywordtype">void</span> ThreadedSocketAcceptor::addThread( <span class="keywordtype">int</span> s, <span class="keywordtype">int</span> t )
00174 { <a class="code" href="_call_stack_8h.html#a0">QF_STACK_PUSH</a>(ThreadedSocketAcceptor::addThread)
00175 
00176   <a class="code" href="class_f_i_x_1_1_locker.html">Locker</a> l(m_mutex);
00177 
00178   <a class="code" href="class_f_i_x_1_1_threaded_socket_acceptor.html#r3">m_threads</a>[ s ] = t;
00179 
00180   <a class="code" href="_call_stack_8h.html#a1">QF_STACK_POP</a>
00181 }
00182 
<a name="l00183"></a><a class="code" href="class_f_i_x_1_1_threaded_socket_acceptor.html#d7">00183</a> <span class="keywordtype">void</span> ThreadedSocketAcceptor::removeThread( <span class="keywordtype">int</span> s )
00184 { <a class="code" href="_call_stack_8h.html#a0">QF_STACK_PUSH</a>(ThreadedSocketAcceptor::removeThread)
00185 
00186   <a class="code" href="class_f_i_x_1_1_locker.html">Locker</a> l(m_mutex);
00187   SocketToThread::iterator i = <a class="code" href="class_f_i_x_1_1_threaded_socket_acceptor.html#r3">m_threads</a>.find( s );
00188   <span class="keywordflow">if</span> ( i != <a class="code" href="class_f_i_x_1_1_threaded_socket_acceptor.html#r3">m_threads</a>.end() )
00189   {
00190     <a class="code" href="namespace_f_i_x.html#a2942">thread_detach</a>( i-&gt;second );
00191     <a class="code" href="class_f_i_x_1_1_threaded_socket_acceptor.html#r3">m_threads</a>.erase( i );
00192   }
00193 
00194   <a class="code" href="_call_stack_8h.html#a1">QF_STACK_POP</a>
00195 }
00196 
<a name="l00197"></a><a class="code" href="class_f_i_x_1_1_threaded_socket_acceptor.html#h0">00197</a> <a class="code" href="_utility_8h.html#a1">THREAD_PROC</a> ThreadedSocketAcceptor::socketAcceptorThread( <span class="keywordtype">void</span>* p )
00198 { <a class="code" href="_call_stack_8h.html#a4">QF_STACK_TRY</a>
00199   <a class="code" href="_call_stack_8h.html#a0">QF_STACK_PUSH</a>(ThreadedSocketAcceptor::socketAcceptorThread)
00200 
00201   <a class="code" href="struct_f_i_x_1_1_threaded_socket_acceptor_1_1_acceptor_thread_info.html">AcceptorThreadInfo</a> * info = reinterpret_cast &lt; AcceptorThreadInfo* &gt; ( p );
00202 
00203   <a class="code" href="class_f_i_x_1_1_threaded_socket_acceptor.html">ThreadedSocketAcceptor</a>* pAcceptor = info-&gt;m_pAcceptor;
00204   <span class="keywordtype">int</span> s = info-&gt;m_socket;
00205   <span class="keywordtype">int</span> port = info-&gt;m_port;
00206   <span class="keyword">delete</span> info;
00207 
00208   <span class="keywordtype">int</span> noDelay = 0;
00209   <a class="code" href="namespace_f_i_x.html#a2924">socket_getsockopt</a>( s, TCP_NODELAY, noDelay );
00210 
00211   <span class="keywordtype">int</span> socket = 0;
00212   <span class="keywordflow">while</span> ( ( !pAcceptor-&gt;<a class="code" href="class_f_i_x_1_1_acceptor.html#a11">isStopped</a>() &amp;&amp; ( socket = <a class="code" href="namespace_f_i_x.html#a2918">socket_accept</a>( s ) ) &gt;= 0 ) )
00213   {
00214     <span class="keywordflow">if</span>( noDelay )
00215       <a class="code" href="namespace_f_i_x.html#a2923">socket_setsockopt</a>( socket, TCP_NODELAY );
00216 
00217     Sessions sessions = pAcceptor-&gt;<a class="code" href="class_f_i_x_1_1_threaded_socket_acceptor.html#r1">m_portToSessions</a>[port];
00218 
00219     <a class="code" href="class_f_i_x_1_1_threaded_socket_connection.html">ThreadedSocketConnection</a> * pConnection =
00220       <span class="keyword">new</span> <a class="code" href="class_f_i_x_1_1_threaded_socket_connection.html">ThreadedSocketConnection</a>( socket, sessions, pAcceptor-&gt;<a class="code" href="class_f_i_x_1_1_acceptor.html#a12">getApplication</a>(), *pAcceptor );
00221 
00222     <a class="code" href="struct_f_i_x_1_1_threaded_socket_acceptor_1_1_connection_thread_info.html">ConnectionThreadInfo</a>* info = <span class="keyword">new</span> <a class="code" href="struct_f_i_x_1_1_threaded_socket_acceptor_1_1_connection_thread_info.html">ConnectionThreadInfo</a>( pAcceptor, pConnection );
00223 
00224     {
00225       <a class="code" href="class_f_i_x_1_1_locker.html">Locker</a> l( pAcceptor-&gt;<a class="code" href="class_f_i_x_1_1_threaded_socket_acceptor.html#r4">m_mutex</a> );
00226 
00227       std::stringstream stream;
00228       stream &lt;&lt; <span class="stringliteral">"Accepted connection from "</span> &lt;&lt; <a class="code" href="namespace_f_i_x.html#a2935">socket_peername</a>( socket ) &lt;&lt; <span class="stringliteral">" on port "</span> &lt;&lt; port;
00229       pAcceptor-&gt;<a class="code" href="class_f_i_x_1_1_acceptor.html#a14">onEvent</a>( stream.str() );
00230 
00231       <span class="keywordtype">unsigned</span> thread;
00232       <span class="keywordflow">if</span> ( !<a class="code" href="namespace_f_i_x.html#a2939">thread_spawn</a>( &amp;<a class="code" href="class_f_i_x_1_1_threaded_socket_acceptor.html#h1">socketConnectionThread</a>, info, thread ) )
00233         <span class="keyword">delete</span> info;
00234       pAcceptor-&gt;<a class="code" href="class_f_i_x_1_1_threaded_socket_acceptor.html#d6">addThread</a>( socket, thread );
00235     }
00236   }
00237 
00238   <span class="keywordflow">if</span>( !pAcceptor-&gt;<a class="code" href="class_f_i_x_1_1_acceptor.html#a11">isStopped</a>() )
00239     pAcceptor-&gt;<a class="code" href="class_f_i_x_1_1_threaded_socket_acceptor.html#d7">removeThread</a>( s );
00240 
00241   pAcceptor-&gt;<a class="code" href="class_f_i_x_1_1_acceptor.html#a14">onEvent</a>( <span class="stringliteral">"ThreadedSocketInitiator stopped"</span> );
00242 
00243   <span class="keywordflow">return</span> 0;
00244 
00245   <a class="code" href="_call_stack_8h.html#a1">QF_STACK_POP</a>
00246   <a class="code" href="_call_stack_8h.html#a5">QF_STACK_CATCH</a>
00247 }
00248 
<a name="l00249"></a><a class="code" href="class_f_i_x_1_1_threaded_socket_acceptor.html#h1">00249</a> <a class="code" href="_utility_8h.html#a1">THREAD_PROC</a> ThreadedSocketAcceptor::socketConnectionThread( <span class="keywordtype">void</span>* p )
00250 { <a class="code" href="_call_stack_8h.html#a4">QF_STACK_TRY</a>
00251   <a class="code" href="_call_stack_8h.html#a0">QF_STACK_PUSH</a>(ThreadedSocketAcceptor::socketConnectionThread)
00252 
00253   <a class="code" href="struct_f_i_x_1_1_threaded_socket_acceptor_1_1_connection_thread_info.html">ConnectionThreadInfo</a> * info = reinterpret_cast &lt; ConnectionThreadInfo* &gt; ( p );
00254 
00255   <a class="code" href="class_f_i_x_1_1_threaded_socket_acceptor.html">ThreadedSocketAcceptor</a>* pAcceptor = info-&gt;m_pAcceptor;
00256   <a class="code" href="class_f_i_x_1_1_threaded_socket_connection.html">ThreadedSocketConnection</a>* pConnection = info-&gt;m_pConnection;
00257   <span class="keyword">delete</span> info;
00258 
00259   <span class="keywordtype">int</span> socket = pConnection-&gt;<a class="code" href="class_f_i_x_1_1_threaded_socket_connection.html#a4">getSocket</a>();
00260 
00261   <span class="keywordflow">while</span> ( pConnection-&gt;<a class="code" href="class_f_i_x_1_1_threaded_socket_connection.html#a5">read</a>() ) {}
00262   <span class="keyword">delete</span> pConnection;
00263   <span class="keywordflow">if</span>( !pAcceptor-&gt;<a class="code" href="class_f_i_x_1_1_acceptor.html#a11">isStopped</a>() )
00264     pAcceptor-&gt;<a class="code" href="class_f_i_x_1_1_threaded_socket_acceptor.html#d7">removeThread</a>( socket );
00265   <span class="keywordflow">return</span> 0;
00266 
00267   <a class="code" href="_call_stack_8h.html#a1">QF_STACK_POP</a>
00268   <a class="code" href="_call_stack_8h.html#a5">QF_STACK_CATCH</a>
00269 }
00270 }
</pre></div><hr><address><small>
Generated on Thu Sep 14 08:52:37 2006 for QuickFIX by <a href="http://www.doxygen.org/index.html">
<img src="doxygen.gif" alt="doxygen" align="middle" border=0 width=110 height=53>
</a> 1.3.6-20040222 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,
 &copy;&nbsp;1997-2001</small></address>
</body>
</html>
